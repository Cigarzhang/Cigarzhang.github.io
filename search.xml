<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表</title>
      <link href="//2362a8ea.html"/>
      <url>//2362a8ea.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一部分：单链表"><a href="#第一部分：单链表" class="headerlink" title="第一部分：单链表"></a>第一部分：单链表</h1><h2 id="1-单链表的定义"><a href="#1-单链表的定义" class="headerlink" title="1.单链表的定义"></a>1.单链表的定义</h2><p>链表由一系列不必在内存中相连的结构组成。每一个结构均含有表元素和指向包含该元素后继元的结构的指针。我们称之为Next指针。最后一个单元的Next指针指向Null。</p><p><img src="https://p.ipic.vip/bf7ius.png" alt="1bddbb0e0761bcb96359f3aa7ff6198c"></p><h2 id="2-单链表的操作"><a href="#2-单链表的操作" class="headerlink" title="2.单链表的操作"></a>2.单链表的操作</h2><h3 id="1-定义头文件list-h"><a href="#1-定义头文件list-h" class="headerlink" title="(1)定义头文件list.h"></a>(1)定义头文件<code>list.h</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ifndef _List_h</span><br><span class="line"><span class="comment">//前置声明一个结构体Node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span> </span><br><span class="line"><span class="comment">//把指向Node 的指针Node* 改名为PtrToNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="comment">//增强代码易读性，List代表整个链表，Position代表寻找元素的位置</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"><span class="comment">//链表清空 </span></span><br><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">(List L)</span>;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(List L)</span>;</span><br><span class="line"><span class="comment">//判断当前位置是否是链表的末尾的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsLast</span><span class="params">(Position, List L)</span>;</span><br><span class="line"><span class="comment">//寻找元素位置</span></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, List L)</span>;</span><br><span class="line"><span class="comment">//删除链表元素  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(ElementType X, List L)</span>;</span><br><span class="line">Position <span class="title function_">FindPrevious</span><span class="params">(ElementType X, List L, Position P)</span>;</span><br><span class="line"><span class="comment">//链表插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(ElementType X, List L, Position P)</span>;</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteList</span><span class="params">(List L)</span>;</span><br><span class="line">Position <span class="title function_">Header</span><span class="params">(List L)</span>;</span><br><span class="line">Position <span class="title function_">First</span><span class="params">(List L)</span>;</span><br><span class="line">Position <span class="title function_">Advance</span><span class="params">(Position P)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_List_h</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  ElementType Element;</span><br><span class="line">  Position Next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-判断链表是否为空"><a href="#2-判断链表是否为空" class="headerlink" title="(2)判断链表是否为空"></a>(2)判断链表是否为空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否为空。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 代表链表的指针。这是一个指向链表头部节点的指针。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 如果链表为空，则返回1（真）；否则返回0（假）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(List L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查链表头部节点的 &quot;Next&quot; 指针是否为NULL。</span></span><br><span class="line">    <span class="comment">// 如果 &quot;Next&quot; 指针为NULL，这意味着链表没有任何实际的数据节点，</span></span><br><span class="line">    <span class="comment">// 因此链表是空的。</span></span><br><span class="line">    <span class="keyword">return</span> L-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-判断给定位置是否为链表的最后一个节点"><a href="#3-判断给定位置是否为链表的最后一个节点" class="headerlink" title="(3)判断给定位置是否为链表的最后一个节点"></a>(3)判断给定位置是否为链表的最后一个节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断给定位置是否为链表的最后一个节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param P 代表链表中的一个位置，通常是一个节点的指针。</span></span><br><span class="line"><span class="comment"> * @param L 代表整个链表。在这个函数中，L实际上没有被使用，但为了接口的一致性，它仍然被包含在参数列表中。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 如果P是链表的最后一个节点，则返回1（真）；否则返回0（假）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsLast</span><span class="params">(Position P, List L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查给定位置（节点）的 &quot;Next&quot; 指针是否为NULL。</span></span><br><span class="line">    <span class="comment">// 如果 &quot;Next&quot; 指针为NULL，这意味着P是链表的最后一个节点。</span></span><br><span class="line">    <span class="keyword">return</span> P-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-在链表L中查找值为X的第一个节点"><a href="#4-在链表L中查找值为X的第一个节点" class="headerlink" title="(4)在链表L中查找值为X的第一个节点"></a>(4)在链表L中查找值为X的第一个节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表L中查找值为X的第一个节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param X 要查找的元素值。</span></span><br><span class="line"><span class="comment"> * @param L 代表整个链表，通常是头部节点的指针。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 如果找到了值为X的节点，则返回该节点的位置；</span></span><br><span class="line"><span class="comment"> *         如果没有找到，返回NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Position <span class="title function_">Find</span><span class="params">(ElementType X, List L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始从链表的第一个实际数据节点（头部节点的下一个节点）进行搜索。</span></span><br><span class="line">    P = L-&gt;Next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，直到找到值为X的节点，或遍历到链表的末尾。</span></span><br><span class="line">    <span class="comment">// 注意：这里有两个条件：P != NULL 确保我们没有到达链表的末尾；</span></span><br><span class="line">    <span class="comment">// P-&gt;Element != X 确保当前节点的值不是我们正在查找的值。</span></span><br><span class="line">    <span class="keyword">while</span> (P != <span class="literal">NULL</span> &amp;&amp; P -&gt; Element != X)</span><br><span class="line">        P = P-&gt;Next;  <span class="comment">// 移动到链表中的下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回找到的节点的位置，或NULL（如果没有找到）。</span></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-删除链表L中值为X的第一个元素"><a href="#5-删除链表L中值为X的第一个元素" class="headerlink" title="(5)删除链表L中值为X的第一个元素"></a>(5)删除链表L中值为X的第一个元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表L中值为X的第一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param X 要删除的元素值。</span></span><br><span class="line"><span class="comment"> * @param L 要操作的链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(ElementType X, List L)</span> &#123;</span><br><span class="line">    Position P, TmpCell; <span class="comment">// 定义两个指针，一个用于查找，一个用于临时存储。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找值为X的元素的前一个元素。</span></span><br><span class="line">    P = FindPrevious(X, L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果P的下一个元素不是链表的最后一个元素，那么值为X的元素存在于链表中。</span></span><br><span class="line">    <span class="keyword">if</span> (!IsLast(P, L)) &#123;</span><br><span class="line">        TmpCell = P-&gt;Next;          <span class="comment">// 保存要删除的元素的位置。</span></span><br><span class="line">        P-&gt;Next = TmpCell-&gt;Next;   <span class="comment">// 跳过要删除的元素，将P的Next指针指向要删除元素的下一个元素。</span></span><br><span class="line">        <span class="built_in">free</span>(TmpCell);             <span class="comment">// 释放要删除的元素占用的内存。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-找到链表中值为X的元素的前一个元素"><a href="#6-找到链表中值为X的元素的前一个元素" class="headerlink" title="(6)找到链表中值为X的元素的前一个元素"></a>(6)找到链表中值为X的元素的前一个元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到链表中值为X的元素的前一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param X 要查找的元素值。</span></span><br><span class="line"><span class="comment"> * @param L 链表。</span></span><br><span class="line"><span class="comment"> * @return 返回指向值为X的元素的前一个元素的指针。如果未找到X或X是第一个元素，则返回链表的头部。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Position <span class="title function_">FindPrevious</span><span class="params">(ElementType X, List L)</span> &#123;</span><br><span class="line">    Position P;  <span class="comment">// 用于遍历链表的指针。</span></span><br><span class="line"></span><br><span class="line">    P = L;  <span class="comment">// 开始于链表的头部。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，直到链表结束或找到值为X的元素。</span></span><br><span class="line">    <span class="keyword">while</span> (P-&gt;Next != <span class="literal">NULL</span> &amp;&amp; P-&gt;Next-&gt;Element != X)  <span class="comment">// 注意：这里有一个小错误，应该是 P-&gt;Next 而不是 P -&gt; next</span></span><br><span class="line">        P = P-&gt;Next;  <span class="comment">// 移动到链表的下一个元素。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果循环结束，P指向值为X的元素的前一个元素，或者X未在链表中找到。</span></span><br><span class="line">    <span class="keyword">return</span> P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：本段代码为了考虑，如果X出现不止一次或者根本没有，就调用FindPrevious函数找出含有X的表元的前驱元P。实现删除程序。</p><p><img src="https://p.ipic.vip/om5ujh.png" alt="2f20d5bfa289b9f4a8f98f3403146c4f"></p><h3 id="7-在链表中插入一个元素"><a href="#7-在链表中插入一个元素" class="headerlink" title="(7)在链表中插入一个元素"></a>(7)在链表中插入一个元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(ElementType X, List L, Position P)</span> &#123;</span><br><span class="line">    Position TmpCell;  <span class="comment">// 用于存储新节点的指针。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新节点动态分配内存。</span></span><br><span class="line">    TmpCell = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="comment">// 检查内存是否成功分配。</span></span><br><span class="line">    <span class="keyword">if</span> (TmpCell == <span class="literal">NULL</span>)</span><br><span class="line">        FatalError(<span class="string">&quot;Out of space!!!&quot;</span>);  <span class="comment">// 如果没有足够的内存，发出致命错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新节点的数据。</span></span><br><span class="line">    TmpCell-&gt;Element = X;</span><br><span class="line">    <span class="comment">// 将新节点的Next指针设置为P指向节点的下一个节点。</span></span><br><span class="line">    TmpCell-&gt;Next = P-&gt;Next;</span><br><span class="line">    <span class="comment">// 将P指向节点的Next指针设置为新节点，从而在P之后插入新节点。</span></span><br><span class="line">    P-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-删除链表L中的所有元素并释放其内存"><a href="#8-删除链表L中的所有元素并释放其内存" class="headerlink" title="(8)删除链表L中的所有元素并释放其内存"></a>(8)删除链表L中的所有元素并释放其内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表L中的所有元素并释放其内存。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 要清空的链表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteList</span><span class="params">(List L)</span> &#123;</span><br><span class="line">    Position P, Tmp;  <span class="comment">// 两个临时指针，用于遍历链表和释放内存。</span></span><br><span class="line"></span><br><span class="line">    P = L-&gt;Next;  <span class="comment">// 开始于链表的第一个数据节点（头节点后的节点）。</span></span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;  <span class="comment">// 将链表头设置为一个空链表。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并释放每个节点的内存。</span></span><br><span class="line">    <span class="keyword">while</span> (P != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Tmp = P-&gt;Next;  <span class="comment">// 保存当前节点的下一个节点。</span></span><br><span class="line">        <span class="built_in">free</span>(P);       <span class="comment">// 释放当前节点的内存。</span></span><br><span class="line">        P = Tmp;       <span class="comment">// 移动到下一个节点。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkList </tag>
            
            <tag> DS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解C和指针</title>
      <link href="//a33c1bed.html"/>
      <url>//a33c1bed.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-指针"><a href="#1-指针" class="headerlink" title="1. 指针"></a>1. 指针</h2><h3 id="1-1-指针和内存"><a href="#1-1-指针和内存" class="headerlink" title="1.1 指针和内存"></a>1.1 指针和内存</h3><h4 id="1-1-1简介"><a href="#1-1-1简介" class="headerlink" title="1.1.1简介"></a>1.1.1简介</h4><p>程序在编译后，会以三种形式使用内存：</p><ul><li><p>静态/ 全局内存 </p><p>静态声明的变量分配在这里，全局变量也使用这部分内存。这些变量在程序开始运行时分配，直到程序终止才消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。</p></li><li><p>自动内存</p><p>这些变量在函数内部声明，并且在函数被调用时才创建。 它们的作用域局限于函数内部，而且生命周期限制在函数的执行时间内。</p></li><li><p>动态内存</p><p>内存分配在堆上，可以根据需要释放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针，这是第2章重点。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">作用域</th><th style="text-align:left">生命周期</th></tr></thead><tbody><tr><td style="text-align:left">全局内存</td><td style="text-align:left">整个文件</td><td style="text-align:left">应用程序的生命周期</td></tr><tr><td style="text-align:left">静态内存</td><td style="text-align:left">声明它的函数内部</td><td style="text-align:left">应用程序的生命周期</td></tr><tr><td style="text-align:left">自动内存（局部内存）</td><td style="text-align:left">声明它的函数内部</td><td style="text-align:left">限制在函数执行时间内</td></tr><tr><td style="text-align:left">动态内存</td><td style="text-align:left">由引用该内存的指针决定</td><td style="text-align:left">直到内存释放</td></tr></tbody></table></div><p>​    指针变量包含内存中别的变量、对象或函数的地址。对象就是内存分配函数 (比如malloc)分配的内存。指针通常根据所指的数据类型来声明。对象可以是任何C数据类型，如整数、字符、字符串或结构体。然而，指针本身并没有包含所引用数据的类型信息，指针只包含地址。</p><hr><h4 id="1-1-2初始化"><a href="#1-1-2初始化" class="headerlink" title="1.1.2初始化"></a>1.1.2初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明指针</span></span><br><span class="line"><span class="type">int</span> *pi1;</span><br><span class="line"><span class="type">int</span>* pi2;</span><br><span class="line"><span class="type">int</span>* pi3;</span><br><span class="line"><span class="type">int</span>*pi4;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci    <span class="comment">/*pci是一个指向整数常量的指针变量*/</span></span><br><span class="line"><span class="type">int</span> *pi;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">pi = &amp;num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Address of num: %d Value: %d\n&quot;</span>,&amp;num,num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Address of pi: %d Value: %d\n&quot;</span>,&amp;pi,pi);  <span class="comment">/*打印地址*/</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>格式说明符</th><th>含义</th></tr></thead><tbody><tr><td>%x</td><td>将值显示为十六进制数</td></tr><tr><td>%o</td><td>将值显示为八进制数</td></tr><tr><td>%p</td><td>将值显示为实现专用的格式，通常是十六进制数</td></tr></tbody></table></div><p><strong>Tips：</strong></p><ul><li>星号两边的空白字符无关紧要，空白符的使用是个人爱好；</li><li>星号将变量声明为指针；</li><li>pi 的内容最终应该赋值为一个整数变量的地址；</li><li>如果变量没有被初始化，将包含的是垃圾数据；</li><li>指针的实现中没有内部信息表明自己指向的是什么类型的数据或者内容是否合法，不过，指针有类型，而且如果没有正确使用，编译器会频繁抱怨；</li><li>尽管不经过初始化就可以使用指针，但只有初始化后，指针才会正常工作；</li><li>很多程序员都发现倒过来读声明就没那么复杂了；</li><li>地址操作符&amp;会返回操作数的地址，我们可以用这个操作符来初始化pi指针；</li><li>把整数赋值给指针 一般都会导致警告或错误，不过，也可以把整数转换为指向整数的指针<code>pi = (int *)num;</code></li><li>尽快初始化指针是一个好习惯;</li><li>%p和%x的不同之处在于:%p一般会把数字显示为十六进制大写。如果没有特别说明，我们用%p作为地址的说明符;</li><li>让打印地址变得更为复杂的是，在虛拟操作系统上显示的指针地址 一般不是真实的物理内存地址;</li><li>间接引用操作符 (*)返回指针变量指向的值，一般称为解引指针;</li><li>指针可以声明为指向函数,如<code>void (*foo) ();</code>,指针的名字是foo;</li></ul><hr><h4 id="1-1-3Null的概念"><a href="#1-1-3Null的概念" class="headerlink" title="1.1.3Null的概念"></a>1.1.3Null的概念</h4><p>​        NULL被赋值给指针就意味着指针不指向任何东西。null概念是指指针包含了一个特殊的值 ， 和别的指针不一样 ， 它没有指向任何 内存区域 。 两个null指针总是相等的。尽管不常见，但每一种指针类型 (如宇符指针和整数指针)都可以有对应的null指针类型。<br>​        Null概念是通过null指针常量来支持的一种抽象。这个常量可能是也可能不是常量0 ，C 程序员不需要关心实际的内部表示。<br>​        NULL宏是强制类型转换为void指针的整数常量0。在很多库中定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure><p>​        如果要把null值赋给pi，就像下面那样用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi = null;</span><br></pre></td></tr></table></figure><p>​        null指针和未初始化的指针不同。未初始化的指针可能包含任何值，而包含NULL的指针则不会引用内存中的任何地址。</p><p>​        有趣的是，我们可以给指针赋0，但是不能赋任何别的整数值。看一下下面的赋值操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pi = <span class="number">0</span>;</span><br><span class="line">pi = <span class="literal">NULL</span>;</span><br><span class="line">pi = <span class="number">100</span>; <span class="comment">//语法错误</span></span><br><span class="line">pi = num; <span class="comment">//语法错误</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>任何时候都不应该对null指针进行解引，因为它并不包含合法地址。执行这样的代码会导致程序终止；</li><li>指针被声明为全局或静态，就会在程序启动时被初始化为NULL。</li></ul><hr><h4 id="1-1-4void指针"><a href="#1-1-4void指针" class="headerlink" title="1.1.4void指针"></a>1.1.4void指针</h4><p>​        void指针是通用指针，用来存放任何数据类型的引用。下面的例子就是一个void 指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *pv;</span><br></pre></td></tr></table></figure><p>它有两个有趣的性质:</p><ul><li><p>void指针具有与char指针相同的形式和内存对齐方式;</p></li><li><p>void指针和别的指针永远不会相等，不过，两个赋值为NULL的void指针是相等的。</p></li></ul><p>​        任何指针都可以被赋给void指针，它可以被转换回原来的指针类型，这样的话指针的值和原指针的值是相等的。在下面的代码中，int指针被赋给void指针然后 ， 又被赋给int 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> *pi = &amp;num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Value of pi: %p\n&quot;</span>, pi); <span class="type">void</span>* pv = pi;</span><br><span class="line">pi = (<span class="type">int</span>*) pv;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Value of pi: %p\n&quot;</span>, pi);</span><br></pre></td></tr></table></figure><p>​        运行这段代码后，指针地址是 一样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value of pi: 100</span><br><span class="line">Value of pi: 100</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>void指针只用做数据指针，而不能用做函数指针；</li><li>用void指针的时候要小心，如果把任意指针转换为void指针，那就没有什么能阻止你再把它转换成不同的指针类型了；</li><li>sizeof操作符可以用在void指针上，不过我们无法把这个操作符用在void上。</li></ul><hr><h3 id="1-2-指针的长度和类型"><a href="#1-2-指针的长度和类型" class="headerlink" title="1.2 指针的长度和类型"></a>1.2 指针的长度和类型</h3><h4 id="1-2-1-机器内存模型"><a href="#1-2-1-机器内存模型" class="headerlink" title="1.2.1 机器内存模型"></a>1.2.1 机器内存模型</h4><div class="table-container"><table><thead><tr><th>数据类型</th><th>LP64</th><th>ILP64</th><th>LLP64</th><th>ILP32</th><th>LP32</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>short</td><td>16</td><td>16</td><td>16</td><td>16</td><td>16</td></tr><tr><td>_int32</td><td></td><td>32</td><td></td><td></td><td></td></tr><tr><td>int</td><td>32</td><td>64</td><td>32</td><td>32</td><td>16</td></tr><tr><td>long</td><td>64</td><td>64</td><td>32</td><td>32</td><td>32</td></tr><tr><td>long long</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>pointer</td><td>64</td><td>64</td><td>64</td><td>64</td><td>32</td></tr></tbody></table></div><hr><h4 id="1-2-2-指针相关的预定义类型"><a href="#1-2-2-指针相关的预定义类型" class="headerlink" title="1.2.2 指针相关的预定义类型"></a>1.2.2 指针相关的预定义类型</h4><p>​        使用指针时经常用到以下四种预定义类型 。 </p><ul><li><p>size_t</p><p>用于安全的表示长度</p></li><li><p>ptrdiff_t</p><p>用于处理指针算数运算符</p></li><li><p>intptr_t和uintptr_t    </p><p>用于存储指针地址</p></li></ul><p><strong><em>1. 理解size_t</em></strong></p><p><strong>定义：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZE_T</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">size_t</span> sizet= <span class="number">-5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> ‚sizet); <span class="comment">//把sizet当作有符号  打印-5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet); <span class="comment">//把sizet当作无符号整数 高位的1被当做2的乘幂 打印一个很大的数</span></span><br><span class="line"><span class="comment">/*正数则会正常显示*/</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li><p>size_t 用做sizeof操作符的返回值类型，同时也是很多函数的参数类型，包括malloc和strlen；</p></li><li><p>在声明诸如字符数或者数组索引这样的长度变量时用size_t 是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上；</p></li><li><p>通常size_t可以用来存放指针，但是假定size_t和指针一样长不是个好主意。</p></li><li><p>打印size_t 类型的值时要小心，这是无符号值，如果选错格式说明符，可能会得到不可靠的结果。推荐的格式说明符是%zu，不过某些情况下不能用这个说明符，作为替代，可以考虑%u 或%lu。</p></li></ul><p><strong><em>2. 对指针使用sizeof操作符</em></strong></p><p>​    当需要用指针长度时，一定要用sizeof操作符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size of *char: %d\n&quot;</span>, <span class="keyword">sizeof</span> (<span class="type">char</span>*));</span><br></pre></td></tr></table></figure><blockquote><p>输出：<code>Size of *char: 4</code></p></blockquote><p><strong><em>3. 使用intptr _t和uintptr_t</em></strong></p><p><strong>定义：</strong></p><p>​        intptr_ t和uintptr_t类型用来存放指针地址。 它们提供了一种可移植且安全的方法声明指针，而且和系统中使用的指针长度相同，对于把指针转化成整数形式来说很有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">intptr_t</span> *pi = &amp;num;</span><br></pre></td></tr></table></figure><p>​        如果像下面那样试图把整数地址赋给uintptr_t 类型的指针，我们会得到一个语法错误:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> *pu = &amp;num;</span><br></pre></td></tr></table></figure><p>​        错误看起来是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: invalid conversion from &#x27;int*&#x27; to</span><br><span class="line">&#x27;uintptr_t* (aka unsigned int* &#x27; (-fpermissive)</span><br></pre></td></tr></table></figure><p>​        不过，用强制类型转换来赋值是可以的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intptr t *pi = &amp;num;</span><br><span class="line"><span class="type">uintptr_t</span> *pu = (<span class="type">uintptr_t</span>*)&amp;num;</span><br></pre></td></tr></table></figure><p>​        如果不转换类型，不能将uintptr_t 用于共他类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">uintptr_t</span> *pc = (<span class="type">uintptr_t</span>*)&amp;c;</span><br></pre></td></tr></table></figure><ul><li>避免把指针转换成整数。如果指针是64 位，整数只有4字节时就会丢失信息。</li><li>当可移植性和安全性变得重要时，就应该使用这些类型。</li></ul><h3 id="1-3-C的动态内存管理"><a href="#1-3-C的动态内存管理" class="headerlink" title="1.3 C的动态内存管理"></a>1.3 C的动态内存管理</h3><p><strong>动态内存管理：</strong>C语言通过手动的分配和释放函数对<strong>堆</strong>进行操作</p><h4 id="1-3-1-动态内存分配"><a href="#1-3-1-动态内存分配" class="headerlink" title="1.3.1 动态内存分配"></a>1.3.1 动态内存分配</h4><h5 id="1-malloc函数"><a href="#1-malloc函数" class="headerlink" title="(1) malloc函数"></a>(1) <strong>malloc</strong>函数</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span> <span class="comment">//不接受参数为负</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>size</code>: 需要分配的内存大小（以字节为单位）。</li></ul><p>返回值：</p><ul><li>如果成功，返回指向分配的内存的指针。</li><li>如果失败，返回NULL。</li></ul><p>典型用法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 分配内存空间用于存储5个整数</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li><p>从堆上分配内存。</p></li><li><p>内存不会被修改或是清空。</p></li><li><p>返回首字节的地址。</p></li><li><p>在返回前先检查NULL。</p></li><li><p>分配内存失败：如果声明一个指针，但在没有使用之前为它指向的地址分配内存，那么内存通常会包含垃圾，这往往会导致一个无效内存引用的错误。</p></li><li><p>要给malloc传递正确的参数—为数据类型分配制定字节数时尽量用sizeof操作符。</p></li><li><p>确认所分配的内存数（基于使用的操作系统，一般不考虑）。</p></li><li><p>初始化静态或全局变量时不能调用函数。</p></li><li><p>在编译器看来作为初始化操作符的<code>=</code>和作为赋值操作符的<code>=</code>不一样.</p></li></ul><h5 id="2-calloc函数"><a href="#2-calloc函数" class="headerlink" title="(2) calloc函数"></a>(2) calloc函数</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>nmemb</code>: 需要分配的元素数量。</li><li><code>size</code>: 每个元素的大小（以字节为单位）。</li></ul><p>返回值：</p><ul><li>如果成功，返回指向分配的内存的指针，并且内存区域已清零。</li><li>如果失败，返回NULL。</li></ul><p>典型用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 分配内存空间用于存储5个整数，并将其初始化为0</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组，所有元素都应该初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印修改后的数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ol><li>calloc会在分配的同时清空内存。</li><li>清空内存的意思是将其内容置为二进制0。</li><li>cfree函数已经没用了。</li></ol><h5 id="3-realloc函数"><a href="#3-realloc函数" class="headerlink" title="(3) realloc函数"></a>(3) realloc函数</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> new_size)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>ptr</code>: 指向原先分配的内存的指针。如果为NULL，则<code>realloc</code>将工作为<code>malloc</code>。</li><li><code>new_size</code>: 新的内存大小（以字节为单位）。</li></ul><p>返回值：</p><ul><li>如果成功，返回一个指向新分配内存的指针（可能与原指针不同）。</li><li>如果失败，返回NULL，并且原指针仍然有效。</li></ul><p>典型用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    arr = <span class="built_in">realloc</span>(arr, <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 调整内存大小</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存重新分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr);  <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-alloca函数"><a href="#4-alloca函数" class="headerlink" title="(4) alloca函数"></a>(4) alloca函数</h5><p>函数原型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">alloca</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li><code>size</code>: 需要分配的内存大小（以字节为单位）。</li></ul><p>返回值:</p><ul><li>返回一个指针，指向分配的内存。</li></ul><p><strong>注意点:</strong></p><ul><li><code>alloca</code>分配的内存是在堆栈上，而不是在堆上。</li><li>函数返回时，<code>alloca</code>分配的内存将被自动释放，不需要调用<code>free</code>函数来释放它。</li></ul><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = alloca(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 在堆栈上分配内存空间用于存储5个整数</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-free函数"><a href="#5-free函数" class="headerlink" title="(5) free函数"></a>(5) free函数</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>ptr</code>: 指向需要释放的内存的指针。</li></ul><p><strong>注意点：</strong></p><ul><li>一块内存只应该被释放一次。重复释放同一块内存是一个严重的程序错误。</li><li>释放后的内存不应再次使用。</li></ul><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = <span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 分配内存空间用于存储5个整数</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-迷途指针"><a href="#1-3-2-迷途指针" class="headerlink" title="1.3.2 迷途指针"></a>1.3.2 迷途指针</h4><p>迷途指针，也叫做野指针，是指向一个未知或无效内存地址的指针。这样的指针可能会导致程序崩溃或者其它不可预测的行为。下面是一些常见的迷途指针产生的情况和相应的示例代码：</p><h5 id="1-未初始化的指针"><a href="#1-未初始化的指针" class="headerlink" title="(1) 未初始化的指针"></a>(1) 未初始化的指针</h5><p>指针变量声明后未进行初始化，它所指向的内存地址是不确定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr;  <span class="comment">// 未初始化的指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr);  <span class="comment">// 试图访问未知内存地址，可能导致程序崩溃</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-指向已释放内存的指针"><a href="#2-指向已释放内存的指针" class="headerlink" title="(2) 指向已释放内存的指针"></a>(2) 指向已释放内存的指针</h5><p>使用<code>free</code>函数释放了一块内存后，再次访问该内存是未定义的行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *ptr = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);  <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr);  <span class="comment">// 试图访问已释放的内存，可能导致程序崩溃</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-指向超出数组边界的指针"><a href="#3-指向超出数组边界的指针" class="headerlink" title="(3) 指向超出数组边界的指针"></a>(3) 指向超出数组边界的指针</h5><p>如果指针指向数组的边界之外，那么尝试访问这样的内存地址也是未定义的行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr = arr + <span class="number">5</span>;  <span class="comment">// 指向数组边界之外的内存地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr);  <span class="comment">// 试图访问数组边界之外的内存，可能导致程序崩溃</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-动态内存分配技术"><a href="#1-3-3-动态内存分配技术" class="headerlink" title="1.3.3 动态内存分配技术"></a>1.3.3 动态内存分配技术</h4><h5 id="1）C语言的垃圾处理机制"><a href="#1）C语言的垃圾处理机制" class="headerlink" title="(1）C语言的垃圾处理机制"></a>(1）C语言的垃圾处理机制</h5><p>在C语言中，动态内存分配和释放完全由程序员控制，这意味着程序员有责任正确地管理内存。不幸的是，C语言没有内置的垃圾收集机制来自动清理不再使用的内存，这可能导致两种主要类型的内存问题：内存泄漏和迷途指针（野指针）。</p><p><strong>1)  内存泄漏:</strong></p><p>内存泄漏是当程序动态分配的内存没有被释放，而程序已无法再访问这块内存时发生的。通常，这是因为没有保存指向该内存的指针。内存泄漏会逐渐消耗系统的可用内存，可能导致程序崩溃。</p><p><strong>预防方法：</strong></p><ul><li>仔细跟踪所有动态分配的内存，并确保在不再需要时释放它。</li><li>使用工具如Valgrind来检测内存泄漏。</li></ul><p><strong>2)  野指针:</strong></p><p>我们已经在前面的部分中详细介绍了野指针。它是指向未知或无效内存地址的指针，可能导致程序崩溃或其他不确定的行为。</p><p><strong>3)  预防方法：</strong></p><ul><li>总是初始化指针变量。</li><li>释放内存后，将指针设置为NULL，以避免后续的悬挂指针引用。</li></ul><h5 id="2-资源获取即初始化（RAII）技术"><a href="#2-资源获取即初始化（RAII）技术" class="headerlink" title="(2)   资源获取即初始化（RAII）技术"></a>(2)   资源获取即初始化（RAII）技术</h5><p>“资源获取即初始化”（RAII, Resource Acquisition Is Initialization）是一种编程技术，它将资源的获取与对象的初始化绑定在一起，资源的释放与对象的销毁绑定在一起。这种技术可以用于管理内存、文件句柄、网络连接等资源。虽然这个概念主要与C++编程相关，但我们也可以在C语言中模仿实现这个概念。</p><p>在C语言中实现RAII，我们可以创建一个结构体来封装资源，并提供初始化和销毁函数来管理资源的生命周期。下面是一个简单的示例，其中我们创建了一个用于管理动态分配内存的<code>RAII_Memory</code>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125; RAII_Memory;</span><br><span class="line"></span><br><span class="line">RAII_Memory <span class="title function_">RAII_Memory_Init</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    RAII_Memory mem;</span><br><span class="line">    mem.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    mem.size = size;</span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RAII_Memory_Destroy</span><span class="params">(RAII_Memory* mem)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(mem-&gt;data);</span><br><span class="line">    mem-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    mem.size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    RAII_Memory mem = RAII_Memory_Init(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用mem.data...</span></span><br><span class="line"></span><br><span class="line">    RAII_Memory_Destroy(&amp;mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><code>RAII_Memory_Init</code>函数分配内存并初始化<code>RAII_Memory</code>结构体。</li><li><code>RAII_Memory_Destroy</code>函数释放内存并重置结构体的成员。</li></ul><p>通过这种方式，我们可以更清晰地管理资源的获取和释放，避免资源泄漏和其他相关问题。</p><h4 id="（3-异常处理函数"><a href="#（3-异常处理函数" class="headerlink" title="（3)  异常处理函数"></a>（3)  异常处理函数</h4><p>在C语言中，我们通常使用<code>malloc</code>, <code>calloc</code>或<code>realloc</code>函数来动态分配内存。这些函数在分配失败时会返回NULL，这是一个特殊的指针值，表示没有足够的内存可供分配。</p><p><strong>1）检查分配是否成功</strong></p><p>在使用<code>malloc</code>, <code>calloc</code>或<code>realloc</code>函数后，我们应该检查返回的指针是否为NULL，以确定分配是否成功。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）使用异常处理函数</strong></p><p>我们可以创建一个专门的异常处理函数来处理内存分配失败的情况。这样可以避免代码重复，并使代码更清晰和组织化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_allocation_failure</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        handle_allocation_failure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，如果内存分配失败，<code>handle_allocation_failure</code>函数将被调用，它将打印一个错误消息并退出程序。</p><hr><hr><h2 id="2-数组和指针"><a href="#2-数组和指针" class="headerlink" title="2.数组和指针"></a>2.数组和指针</h2><h3 id="2-1-数组基本形式"><a href="#2-1-数组基本形式" class="headerlink" title="2.1 数组基本形式"></a>2.1 数组基本形式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> candy[<span class="number">365</span>];  <span class="comment">/*365个浮点数的数组*/</span></span><br><span class="line">  <span class="type">char</span> code[<span class="number">12</span>]  <span class="comment">/*12个字符的数组*/</span></span><br><span class="line">  <span class="type">int</span> states[<span class="number">50</span>];  <span class="comment">/*50个整数的数组*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-数组初始化"><a href="#2-2-数组初始化" class="headerlink" title="2.2 数组初始化"></a>2.2 数组初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> days[] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="keyword">sizeof</span> days / <span class="keyword">sizeof</span> days[<span class="number">0</span>]; index ++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Month %2d has %d days.\n&quot;</span>,index + <span class="number">1</span>,days[index]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>与普通变量相似，在初始化之前数组元素的数值是不定的；</li><li>初始化列表中的元素数目应和数组大小一致；</li><li>如果不初始化数组，数组和为初始化的普通变量一样，气筒存储的是无用值；</li><li>但是如果初始化部分数组，未初始化的数组则将被设置为0；</li><li>当使用空的方括号对数组进行初始化时，编译器会根据列表中的数值数目来确定数组大小；</li><li>注意for循环的控制语句。由于人工计算容易出错，因此可以让计算机来计算数组的打小。符sizeof给出其后的对象或类型的大小( 以字节为单位 )。因此sizeof days是整个数组的打戏哦啊（以字节为单位），sizeof days[0]是一个元素的大小（以字节为单位）。整个数组的大小厨艺单个元素的大小就是数组中元素的数目。</li><li>数组索引不能超过数组边界，不然会报错。</li></ul><h4 id="对数组使用const的方法"><a href="#对数组使用const的方法" class="headerlink" title="对数组使用const的方法"></a>对数组使用const的方法</h4><p>​        有时需要使用只读数组，也就是程序从数组中读取数值，但是程序不向数组中写数据。在这种情况下声明并初始化数组时，建议使用关键字const。声明数组<code>const int a[3] = &#123;1,2,3&#125;;</code></p><p>​        这样，程序会把数组中每个元素当成常量来处理。和普通变量一样，需要在声明const数组时对其进行初始化，因为在声明之后，不能再对它进行赋值。</p><h4 id="存储类定义"><a href="#存储类定义" class="headerlink" title="存储类定义"></a>存储类定义</h4><p>​        和其他变量相似，数组可以被定义为多种存储类(storage class)。也就是说，数组实在一个函数内声明，并且声明时没有使用关键字static。</p><p>​        不同存储类有时具有不同的属性。</p><h4 id="指定数组大小"><a href="#指定数组大小" class="headerlink" title="指定数组大小"></a>指定数组大小</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">8</span>;</span><br><span class="line"><span class="type">float</span> a1[<span class="number">5</span>];<span class="comment">//可以；</span></span><br><span class="line"><span class="type">float</span> a2[<span class="number">5</span>*<span class="number">2</span> + <span class="number">1</span>];  <span class="comment">//可以；</span></span><br><span class="line"><span class="type">float</span> a3[<span class="keyword">sizeof</span> (<span class="type">int</span>) + <span class="number">1</span>]; <span class="comment">//可以；</span></span><br><span class="line"><span class="type">float</span> a4[<span class="number">-4</span>];<span class="comment">//不可以，数组大小必须大于0；</span></span><br><span class="line"><span class="type">float</span> a5[<span class="number">0</span>];  <span class="comment">//不可以，数组大小必须大于0；</span></span><br><span class="line"><span class="type">float</span> a6[<span class="number">2.5</span>];<span class="comment">//不可以，数组大小必须是整数；</span></span><br><span class="line"><span class="type">float</span> a7[(<span class="type">int</span>) <span class="number">2.5</span>];   <span class="comment">//可以，把float类型指派为int类型；</span></span><br><span class="line"><span class="type">float</span> a8[n]; <span class="comment">//C99之前不允许；</span></span><br><span class="line"><span class="type">float</span> a9[m];  <span class="comment">// C99之前不允许。</span></span><br></pre></td></tr></table></figure><h3 id="2-3-C99新特性（指定初始化项目）"><a href="#2-3-C99新特性（指定初始化项目）" class="headerlink" title="2.3 C99新特性（指定初始化项目）"></a>2.3 C99新特性（指定初始化项目）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MONTHS 12</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>, [<span class="number">4</span>] = <span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,[<span class="number">1</span>] = <span class="number">29</span>&#125;;</span><br><span class="line">  <span class="type">int</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MONTHS; i ++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d %d\n&quot;</span>,i + <span class="number">1</span>,days[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    输出如下：</p><blockquote><p>1  31</p><p>2  29</p><p>3  0</p><p>4  0</p><p>5  31</p><p>6  30</p><p>7  31</p><p>8  0</p><p>9  0</p><p>10  0</p><p>11  0</p><p>12  0</p></blockquote><ol><li>如果在一个指定初始化项目后跟有不止一个值，则这些值将用来对后续的数组元素初始化。</li><li>如果多次对一个元素进行初始化，则最后一次有效。</li></ol><h3 id="2-4-多维数组"><a href="#2-4-多维数组" class="headerlink" title="2.4 多维数组"></a>2.4 多维数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a[<span class="number">5</span>][<span class="number">12</span>];</span><br></pre></td></tr></table></figure><ul><li>a数组能存储5行12列的浮点数。</li><li>初始化数组时可以省略内部的花括号，只保留最外面的一对花括号。只要保证数值的个数是正确的。初始化效果就是一样的。</li></ul><p><strong>注：</strong>对于多维数组，可以这样直观的理解：一位数组是排成一行的数据，二维数组是放在一个平面上的数据，三维数组是把平面数据一层一层地垒起来。</p><h3 id="2-5-指针和数组"><a href="#2-5-指针和数组" class="headerlink" title="2.5 指针和数组"></a>2.5 指针和数组</h3><p><img src="https://p.ipic.vip/ml99nh.jpg" alt="CamScanner 07-20-2023 09.31" style="zoom: 25%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数组名同时也是该数组首元素的地址，两者都是常量，应为在程序运行的过程中它们保持不变*/</span></span><br><span class="line">flizny == &amp;flizny[<span class="number">0</span>] <span class="comment">//数组名是该数组首元素的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">short</span> dates [size];</span><br><span class="line">  <span class="type">short</span> * pti;</span><br><span class="line">  <span class="type">short</span> index;</span><br><span class="line">  <span class="type">double</span> bills[SIZE];</span><br><span class="line">  <span class="type">double</span> * ptf;</span><br><span class="line">  </span><br><span class="line">  pti = dates; <span class="comment">//把数组地址赋给指针</span></span><br><span class="line">  ptf = bills;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%23s %10s\n&quot;</span>,<span class="string">&quot;short&quot;</span>,<span class="string">&quot;double&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; SIZE; index ++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pointers + %d: %10p %10p\n&quot;</span>,index,pti + index, ptf + index);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>在c中，对一个指针加1的结果是对该指针增加1个存储单元（storage unit）；</li><li>计算机需要知道存储对象所用的字节数，所以声明时不仅要有地址信息，还要声明它所指向对象的类型；</li><li>即使指针是指向标量的，也需要声明指针类型；否则*pt操作不能正确返回数值；</li><li>指针的数值就是它所指向的对象的地址；</li><li>在指针前运用运算符*就可以得到该指针所指向的对象的数值；</li><li>对指针加1，等价于对指针的值加上它指向的对象的字节大小。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dates + <span class="number">2</span> == &amp;date[<span class="number">2</span>]; <span class="comment">/*相同的地址  */</span></span><br><span class="line">* (dates + <span class="number">2</span>) == dates[<span class="number">2</span>];<span class="comment">/*相同的值*/</span></span><br><span class="line">* (dates + <span class="number">2</span>)  <span class="comment">/*dates的第3个元素的的值*/</span></span><br><span class="line">* dates + <span class="number">2</span>    <span class="comment">/*第一个元素的值和2相加*/</span></span><br></pre></td></tr></table></figure><p>​    这些关系总结了数组和指针间的密切关系：可以用指针标识数组的每个元素，并得到每个元素的数值。从本质上说，对同一个对象有两种不同的符号表示方法。C标准在描述数组时，确实借助了指针的概念。</p><h2 id="3-函数和指针"><a href="#3-函数和指针" class="headerlink" title="3.函数和指针"></a>3.函数和指针</h2><h3 id="3-1程序的堆和栈概念"><a href="#3-1程序的堆和栈概念" class="headerlink" title="3.1程序的堆和栈概念"></a>3.1程序的堆和栈概念</h3><p>在程序的执行过程中，其所使用的内存空间主要分为两大区域：栈（Stack）和堆（Heap）。这两个区域有各自的用途，特点和工作方式。</p><h4 id="3-1-1-栈-Stack-："><a href="#3-1-1-栈-Stack-：" class="headerlink" title="3.1.1 栈 (Stack)："></a>3.1.1 栈 (Stack)：</h4><ol><li><p><strong>自动分配/释放</strong>：由编译器自动分配和释放，存放函数的参数值、局部变量等。</p></li><li><p><strong>大小有限</strong>：栈的大小是有限的，超出栈的容量会导致栈溢出。</p></li><li><p><strong>生命周期短</strong>：局部变量只在定义它的函数的执行期间存在。</p></li><li><p><strong>访问速度快</strong>：由于栈是结构化的，数据访问速度更快。</p></li><li><p><strong>局部指针变量</strong>：函数内定义的指针变量存放在栈上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>ptr</code> 是一个局部指针变量，它存放在栈上，指向的<code>x</code>也是在栈上。</p></li></ol><h4 id="3-2-2-堆-Heap-："><a href="#3-2-2-堆-Heap-：" class="headerlink" title="3.2.2 堆 (Heap)："></a>3.2.2 堆 (Heap)：</h4><ol><li><strong>动态分配/释放</strong>：需要程序员手动分配和释放，使用<code>malloc</code>、<code>calloc</code>、<code>free</code>等函数。</li><li><strong>大小几乎无限制</strong>：受限于计算机系统中有效的虚拟内存。</li><li><strong>生命周期长</strong>：直到程序员释放或程序结束。</li><li><strong>访问速度相对较慢</strong>：相比于栈，堆的访问速度稍慢。</li><li><strong>可能导致内存泄漏</strong>：如果程序员分配了内存而忘记释放，会导致内存泄漏。</li></ol><p><strong>动态内存分配</strong>：使用 <code>malloc</code> 或 <code>calloc</code> 分配的内存位于堆上，这些函数返回一个指向分配的内存块的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>arr</code> 是一个局部指针变量（存放在栈上），但它指向的10个整数的内存块是在堆上。</p><p><strong>释放动态内存</strong>：必须使用 <code>free</code> 函数来释放堆上分配的内存，否则可能导致内存泄漏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学导论</title>
      <link href="//8058807d.html"/>
      <url>//8058807d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><h3 id="1-1-图灵模型"><a href="#1-1-图灵模型" class="headerlink" title="1.1 图灵模型"></a>1.1 图灵模型</h3><h4 id="1-1-1-图灵机：什么是图灵机"><a href="#1-1-1-图灵机：什么是图灵机" class="headerlink" title="1.1.1 图灵机：什么是图灵机"></a>1.1.1 图灵机：什么是图灵机</h4><ul><li>Alan Turing（阿兰-图灵）1937年首次提出通用计算机设想：所有的计算都可能在一种特殊的机器上执行。</li><li>是一种数学上的描述，不是一台真实的机器。</li></ul><h4 id="1-1-2-数据处理器"><a href="#1-1-2-数据处理器" class="headerlink" title="1.1.2 数据处理器"></a>1.1.2 数据处理器</h4><p>​        首先暂且把计算机可以被看作一种接收数据输入、处理数据并产生数据输出的<strong>黑盒</strong>。</p><p><img src="https://p.ipic.vip/hcuo8v.png" alt="图片 1"></p><p>​        问题：没有确定计算机能处理的数据是什么。</p><h4 id="1-1-3-可编程数据处理器"><a href="#1-1-3-可编程数据处理器" class="headerlink" title="1.1.3 可编程数据处理器"></a>1.1.3 可编程数据处理器</h4><p>​        图灵模型：可编程计算机</p><p>​        程序：告诉计算机对数据处理的的指令集合</p><p>​        输出数据：根据输入数据+程序，得到输出数据。</p><ul><li><p>相同程序，不同输入数据：输出数据不同。</p></li><li><p>相同输入数据，不同程序：输出数据不同。</p></li><li><p>相同输入数据，相同程序：输出数据相同。</p></li></ul><p>  <img src="https://p.ipic.vip/g53bvp.png" alt="image-20230728214730185" style="zoom: 50%;" /><img src="https://p.ipic.vip/4dspj7.png" alt="image-20230728214745517" style="zoom: 50%;" /></p><p>​        <strong>通用图灵机：</strong>通用图灵机是对现代计算机的首次描述，该机器只要提供合适的程序就能做任何运算。</p><h3 id="1-2-冯-诺依曼模型"><a href="#1-2-冯-诺依曼模型" class="headerlink" title="1.2 冯-诺依曼模型"></a>1.2 冯-诺依曼模型</h3><h4 id="1-2-1-什么是冯-诺依曼模型"><a href="#1-2-1-什么是冯-诺依曼模型" class="headerlink" title="1.2.1 什么是冯-诺依曼模型"></a>1.2.1 什么是冯-诺依曼模型</h4><ul><li><p>科学家冯-诺依曼提出的模型理论。</p></li><li><p>基于通用图灵机建造的计算机都是在存储器(内存/寄存器)上存储数据。</p></li><li><p>鉴于程序和数据在逻辑上是相同的，因此程序也能存储在计算机的存储器中。</p></li></ul><h4 id="1-2-2-4个子系统"><a href="#1-2-2-4个子系统" class="headerlink" title="1.2.2 4个子系统"></a>1.2.2 4个子系统</h4><p><img src="https://p.ipic.vip/rjhyfc.png" alt="image-20230729095508630" style="zoom: 50%;" /></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LR  ControlUnit[控制单元]  ALU[算术逻辑单元]  Memory[存储器]  InputOutput[输入&#x2F;输出单元]  ControlUnit --&gt; ALU  ControlUnit --&gt; Memory  ControlUnit --&gt; InputOutput  InputOutput --&gt; Memory  Memory --&gt; ALU  ALU --&gt; Memory  </pre></div><ul><li><p><strong>存储器</strong>:用来存储数据和程序的区域。</p></li><li><p><strong>算术逻辑单元（ALU）</strong>：用来计算和逻辑运算的地方。</p></li><li><p><strong>控制单元</strong>：对存储器、算术逻辑单元、输入/输出等子系统进行控制操作。</p></li><li><p><strong>输入/输出单元</strong>：输入子系统负责从计算机外部接收输入数据，输出子系统负责从计算机处理结果输出到计算机外部。</p></li></ul><h4 id="1-2-3-存储程序概念"><a href="#1-2-3-存储程序概念" class="headerlink" title="1.2.3 存储程序概念"></a>1.2.3 存储程序概念</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB    Storage(&quot;存储器&quot;)    PrimaryStorage(&quot;主存储器(RAM)&quot;)    SecondaryStorage(&quot;次级存储器&quot;)    Cache(&quot;缓存&quot;)    HardDisk(&quot;硬盘驱动器&quot;)    SSD(&quot;固态硬盘 (SSD)&quot;)    CPU_Cache(&quot;CPU缓存&quot;)    Storage --&gt; PrimaryStorage    Storage --&gt; SecondaryStorage    Storage --&gt; Cache    SecondaryStorage --&gt; HardDisk    SecondaryStorage --&gt; SSD    Cache --&gt; CPU_Cache  </pre></div><ul><li><p>冯-诺依曼模型要求程序也必须存储在存储器（内存）中。</p></li><li><p>现代计算机的存储单元用来存储程序和数据，这意味着程序和数据应该有相同的格式，实际上它们都是以位模式（0和1序列）存储在内存中。</p></li><li><p>什么是位模式？位模式是一种表示，用一串二进制数（0和1）来代表数据或者指令。</p></li></ul><h4 id="1-2-4-指令的顺序执行"><a href="#1-2-4-指令的顺序执行" class="headerlink" title="1.2.4 指令的顺序执行"></a>1.2.4 指令的顺序执行</h4><ul><li><p>冯-诺依曼模型中的一段程序是由一组数量有限的指令组成。</p></li><li><p>控制单元从内存中提取一条指令，解释指令，接着执行指令，也就是说指令是一条接着一条顺序执行的。</p></li></ul><h3 id="1-3-计算机组成部分"><a href="#1-3-计算机组成部分" class="headerlink" title="1.3 计算机组成部分"></a>1.3 计算机组成部分</h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB    Computer(&quot;计算机&quot;)    Hardware(&quot;计算机硬件&quot;)    Data(&quot;计算机数据&quot;)    Software(&quot;计算机软件&quot;)    Computer --&gt; HardwareComputer --&gt; DataComputer --&gt; Software  </pre></div><p>​        <strong>注：</strong>计算机硬件将在稍后章节提到。</p><h4 id="1-3-1-计算机组成部分-数据"><a href="#1-3-1-计算机组成部分-数据" class="headerlink" title="1.3.1 计算机组成部分-数据"></a>1.3.1 计算机组成部分-数据</h4><p>​        冯-诺依曼模型将计算机定义为一台数据处理机，它接收输入数据，处理数据，最后输出数据</p><ul><li>存储数据：计算机是一台<strong>电子设备</strong>，最好的数据存储方式应该是<strong>电子信号</strong>，以电子信号的<strong>出现和消失</strong>（位模式）来存储数据，即以两种状态之一来存储数据。但是日常生活中的数据（文本、图像、声音、视频等）不是以位模式存储的，不能直接存储到计算机中，除非将这类数据转换为位模式。</li></ul><p>​        为什么使用位模式？因为电子设备对位模式的实现简单（通电或不通电，高电压和低电压…）</p><ul><li>组织数据：在数据存储到计算机之前，需要合理有序的组织成不同的格式。将数据从计算机中输出也需要表现不同的形式。</li></ul><h4 id="1-3-2-计算机组成部分-软件"><a href="#1-3-2-计算机组成部分-软件" class="headerlink" title="1.3.2 计算机组成部分-软件"></a>1.3.2 计算机组成部分-软件</h4><p><strong>1. 算法</strong></p><p>​        程序按一系列的指令执行使得编程成为可能，程序员通过指令集中的指令组合完成特定的运算任务，按照有序指令解决问题的的方法就是算法。</p><p><strong>2. 语言</strong></p><ul><li><p>机器语言：程序员编写位模式（0和1的组合）的指令来完成任务。</p></li><li><p>符号语言：随着任务的复杂性越来越高，科学家研究使用符号来表示位模式指令，这样计算机编程语言就诞生了。</p></li></ul><p><strong>3. 软件工程</strong></p><p>​        软件工程指结构化程序的设计和编写，为高效的程序开发而诞生的一门理论体系，这部分后面会讲到。</p><p><strong>4. 操作系统</strong></p><p>​        这部分内容在后面会讲到。</p><h2 id="2-数字系统"><a href="#2-数字系统" class="headerlink" title="2. 数字系统"></a>2. 数字系统</h2><h3 id="2-1-位置化数字系统"><a href="#2-1-位置化数字系统" class="headerlink" title="2.1 位置化数字系统"></a>2.1 位置化数字系统</h3><p>在位置化数字系统中，数字符号所占据的位置决定了其表示的值。</p><p>在该系统中，数字这样表示：</p><p><img src="https://p.ipic.vip/vu6e59.png" alt="image-20230730144809641" style="zoom: 33%;" /></p><p>它的值是：</p><p><img src="https://p.ipic.vip/nlk2td.png" alt="image-20230730145135621" style="zoom: 50%;" /></p><p>其中：S是一套符号集，b是底（或基数），b=S符号集中的符号总数，+/-表示数字为正或负。</p><h4 id="2-1-1-十进制系统-以10为底"><a href="#2-1-1-十进制系统-以10为底" class="headerlink" title="2.1.1 十进制系统(以10为底)"></a>2.1.1 十进制系统(以10为底)</h4><p>符号集$S={0,1,2,3,4,5,6,7,8,9}$</p><p>底$b=10$</p><p><img src="https://p.ipic.vip/zlhvgn.png" alt="image-20230730145316735" style="zoom:40%;" /></p><p>为了简便，通常省略括号、底、和正号。如$+(552.31)$写成$552.31$，底和加号是隐含的。</p><p><strong>注释：</strong></p><ol><li><p>这些符号不能直接存储在计算机中。</p></li><li><p>计算机存储正负数的方式不同。</p></li></ol><p><img src="https://p.ipic.vip/fcdvdd.png" alt="image-20230730145728629"></p><p><img src="https://p.ipic.vip/21re5f.png" alt="image-20230730145748883"></p><p><img src="https://p.ipic.vip/n9twyz.png" alt="image-20230730145915270"></p><p><img src="https://p.ipic.vip/ri6c40.png" alt="image-20230730145932443"></p><p><img src="https://p.ipic.vip/xjwgrs.png" alt="image-20230730145941641"></p><p><img src="https://p.ipic.vip/7hxt26.png" alt="image-20230730150004600" style="zoom: 50%;" /></p><h4 id="2-1-2-二进制系统-以2为底"><a href="#2-1-2-二进制系统-以2为底" class="headerlink" title="2.1.2 二进制系统(以2为底)"></a>2.1.2 二进制系统(以2为底)</h4><p>符号集$S={0,1}$</p><p>底$b=2$</p><p>该系统中的符号常被称为<strong>二进制数码</strong>或<strong>位（位数码）</strong>。   </p><p>数据和程序是以二进制模式（即位模式），存储在计算机中的，这是因为计算机由电子开关制成，它们</p><p>仅有开和关两种状态，1和0分别表示两种不同的状态。</p><p><img src="https://p.ipic.vip/bqnyfz.png" alt="image-20230730151346066" style="zoom: 45%;" /></p><p><img src="https://p.ipic.vip/o9vs7j.png" alt="image-20230730151414715"></p><p><img src="https://p.ipic.vip/2284hj.png" alt="image-20230730152055960"></p><p><img src="https://p.ipic.vip/h2vzqs.png" alt="image-20230730152114294"></p><p><img src="https://p.ipic.vip/v1ll10.png" alt="image-20230730152222436"></p><p><img src="https://p.ipic.vip/0nqcg1.png" alt="image-20230730153405172" style="zoom:0%;" /></p><h4 id="2-1-3-十六进制系统-以16为底"><a href="#2-1-3-十六进制系统-以16为底" class="headerlink" title="2.1.3 十六进制系统(以16为底)"></a>2.1.3 十六进制系统(以16为底)</h4><p>为什么需要十六进制系统？  </p><p>尽管二进制系统用于存储计算机数据，但是不便于在计算机外部表示数字，因为与十进制相比，<strong>二进制符号过长</strong>。但是十进制不能直接存储在计算机中，在二进制和十进制数字之间没有显然的关系，而且它们直接的转换也不快捷。    </p><p>为了克服这个问题，发明了两种位置化系统：十六进制和八进制。  </p><p>符号集$S={0,1,2,3,4,5,6,7,8,9，A，B,C,D,E,F} $   </p><p>说明：$A，B,C,D,E,F分别对应十进制中的10,11,12,13,14,15  不区分字母大小写$   </p><p>底$b = 16$</p><p><img src="https://p.ipic.vip/779lb8.png" alt="image-20230730153813862"></p><p><img src="https://p.ipic.vip/ascnyu.png" alt="image-20230730153828002"></p><p><img src="https://p.ipic.vip/80tf0v.png" alt="image-20230730153856140"></p><p><img src="https://p.ipic.vip/gs2hlk.png" alt="image-20230730153920484"></p><p><strong>注：</strong>尽管一个实数可以用十六进制系统表示，但并不常见。</p><h4 id="2-1-4-八进制系统-以8为底"><a href="#2-1-4-八进制系统-以8为底" class="headerlink" title="2.1.4 八进制系统(以8为底)"></a>2.1.4 八进制系统(以8为底)</h4><p>$符号集S={0,1,2,3,4,5,6,7}$  </p><p>$底b=8$  </p><p>八进制系统用于二进制系统的计算机外部表现形式</p><p><img src="https://p.ipic.vip/jibbkv.png" alt="image-20230730154427199"></p><p><img src="https://p.ipic.vip/6736zt.png" alt="image-20230730154457663"></p><p><img src="https://p.ipic.vip/kdnw76.png" alt="image-20230730154504274" style="zoom:50%;" /></p><p><img src="https://p.ipic.vip/22n0sr.png" alt="image-20230730154602524"></p><p><strong>注：</strong>尽管一个实数可以用八进制系统表示，但并不常见。</p><h4 id="2-1-5-小结"><a href="#2-1-5-小结" class="headerlink" title="2.1.5 小结"></a>2.1.5 小结</h4><p><img src="https://p.ipic.vip/347b8w.png" alt="image-20230730155052624"></p><p><img src="https://p.ipic.vip/5cp7ke.png" alt="image-20230730155104481"></p><h4 id="2-1-6-进制转换"><a href="#2-1-6-进制转换" class="headerlink" title="2.1.6 进制转换"></a>2.1.6 进制转换</h4><h5 id="（1）其它进制转换为十进制"><a href="#（1）其它进制转换为十进制" class="headerlink" title="（1）其它进制转换为十进制"></a>（1）其它进制转换为十进制</h5><p>其它进制转换为十进制是简单而迅速的，将数码乘以其在源系统中的位置量并求和便得到十进制中的数</p><p><img src="https://p.ipic.vip/1h21np.png" alt="image-20230730160119829"></p><h5 id="（2）二进制进制转换为十进制"><a href="#（2）二进制进制转换为十进制" class="headerlink" title="（2）二进制进制转换为十进制"></a>（2）二进制进制转换为十进制</h5><p><img src="https://p.ipic.vip/o6yy1g.png" alt="image-20230730160159773"></p><h5 id="（3）-十六进制进制转换为十进制"><a href="#（3）-十六进制进制转换为十进制" class="headerlink" title="（3） 十六进制进制转换为十进制"></a>（3） 十六进制进制转换为十进制</h5><p><img src="https://p.ipic.vip/7561z6.png" alt="image-20230730160226232"></p><h5 id="（4）八进制进制转换为十进制"><a href="#（4）八进制进制转换为十进制" class="headerlink" title="（4）八进制进制转换为十进制"></a>（4）八进制进制转换为十进制</h5><p><img src="https://p.ipic.vip/4n1ts1.png" alt="image-20230730160901872"></p><h5 id="（5）十进制转换其它进制"><a href="#（5）十进制转换其它进制" class="headerlink" title="（5）十进制转换其它进制"></a>（5）十进制转换其它进制</h5><p>可以将十进制转换为与它等值的其它进制，需要两个过程：</p><ul><li><p>转换整数部分</p><p><img src="https://p.ipic.vip/da1423.png" alt="image-20230730161038843" style="zoom:67%;" /></p></li></ul><p><img src="https://p.ipic.vip/hj5yyn.png" alt="image-20230730161059372" style="zoom: 67%;" /></p><p><strong><em>十进制转换二进制——示例</em></strong></p><p><img src="https://p.ipic.vip/8jtllq.png" alt="image-20230730161141887" style="zoom: 50%;" /></p><p><img src="https://p.ipic.vip/2g580x.png" alt="image-20230730161150386" style="zoom:50%;" /></p><p><strong><em>十进制转换八进制——示例</em></strong></p><p><img src="https://p.ipic.vip/0iby1x.png" alt="image-20230730161255042"></p><p><strong><em>十进制转换十六进制——示例</em></strong></p><p><img src="https://p.ipic.vip/1nb184.png" alt="image-20230730161337775"></p><ul><li>转换小数部分</li></ul><p><img src="https://p.ipic.vip/2g0kw2.png" alt="image-20230730161504249" style="zoom: 67%;" /></p><p><img src="https://p.ipic.vip/kl7g7t.png" alt="image-20230730161515817" style="zoom: 67%;" /></p><p><strong><em>十进制转换二进制——示例</em></strong></p><p><img src="https://p.ipic.vip/i3ghq4.png" alt="image-20230730161619666" style="zoom:50%;" /></p><p><img src="https://p.ipic.vip/btsm02.png" alt="image-20230730161629903" style="zoom:67%;" /></p><p><strong><em>十进制转换八进制——示例</em></strong>    </p><p><img src="https://p.ipic.vip/9kucqq.png" alt="image-20230730161717304"></p><p><strong><em>十进制转换十六进制——示例</em></strong></p><p><img src="https://p.ipic.vip/xd8q4m.png" alt="image-20230730161724815"></p><h5 id="（6）其他进制转化"><a href="#（6）其他进制转化" class="headerlink" title="（6）其他进制转化"></a>（6）其他进制转化</h5><ol><li>二进制&amp;十六进制互转</li></ol><p><img src="https://p.ipic.vip/go52u6.png" alt="image-20230730162140759"></p><ol><li><strong>二进制转十六进制</strong></li></ol><p><img src="https://p.ipic.vip/7laaik.png" alt="image-20230730161943721"></p><ol><li><strong>十六进制转二进制</strong></li></ol><p><img src="https://p.ipic.vip/sobaof.png" alt="image-20230730162001911"></p><ol><li><strong>二进制&amp;八进制互转</strong></li></ol><p><img src="https://p.ipic.vip/mpbfqc.png" alt="image-20230730162015705"></p><ol><li><strong>二进制转八进制</strong></li></ol><p><img src="https://p.ipic.vip/j32xwb.png" alt="image-20230730162200130"></p><ol><li><strong>八进制转二进制</strong></li></ol><p><img src="https://p.ipic.vip/rh0yt7.png" alt="image-20230730162219783" style="zoom: 45%;" /></p><ol><li><strong>八进制&amp;十六进制互转</strong></li></ol><ul><li>八进制转十六进制，可以先转为二进制，再转为十六进制</li><li>十六进制转八进制，可以先转为二进制，再转为八进制</li></ul><p><img src="https://p.ipic.vip/3w2sai.png" alt="image-20230730162258259" style="zoom: 50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
