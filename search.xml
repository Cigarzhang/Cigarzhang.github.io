<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法模版</title>
      <link href="//bb13e2f5.html"/>
      <url>//bb13e2f5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1. 基础算法"></a>1. 基础算法</h1><h2 id="1-1快速排序算法模版"><a href="#1-1快速排序算法模版" class="headerlink" title="1.1快速排序算法模版"></a>1.1快速排序算法模版</h2><pre class="mermaid">graph TD    A((开始)) --> B[选择轴心]    B --> C{左边有元素比轴心小吗}    C --是--> D[将元素移动到左边]    D --> C    C --否--> E{右边有元素比轴心大吗}    E --是--> F[将元素移动到右边]    F --> E    E --否--> G{左右子序列长度>1}    G --是--> B    G --否--> H((结束))</pre><p>​        快速排序是一种常用的排序算法，它的平均复杂度为$O(n \log n)$，且在实践中表现得非常好。它是由C.A.R. Hoare在1960年提出的。它的工作原理是这样的：</p><ol><li>选择一个“轴心”元素x，这段代码中的选择方式是选择中间元素，<code>x = q[l + r &gt;&gt; 1]</code>。</li><li>把所有小于x的元素移动到它的左边，所有大于x的元素移动到它的右边。这个过程叫做划分（partition）。</li><li>对左边和右边的两个子序列递归地执行步骤1和2。</li></ol><p>​        用一个生活中的例子来解释一下，想象一下你正在打扫一间充满各种尺寸书籍的书房。你可以选择一个中间大小的书（这就是轴心），然后把所有小于它的书放在左边，所有大于它的书放在右边。然后，你分别在左边和右边的书堆里重复这个过程，直到每一堆书都按照大小顺序排列好。</p><p>​        证明这个算法的正确性，我们可以从以下几点进行：</p><ol><li>初始情况：当序列长度为1时，序列显然是已排序的。</li><li>递归步骤：通过选择轴心并进行划分，我们知道所有在左边的元素都小于等于x，所有在右边的元素都大于等于x。因此，如果左边和右边的子序列是已排序的，那么整个序列就是已排序的。</li><li>因此，如果我们对左边和右边的子序列递归地执行快速排序，那么最终整个序列就会变成已排序的。</li></ol><p><strong>模版如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span> i ++, <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">    <span class="keyword">do</span> j --, <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">  <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在这个<code>quick_sort</code>函数中，<code>i</code>和<code>j</code>被设置为<code>l-1</code>和<code>r+1</code>，是为了让<code>i</code>和<code>j</code>在循环的开始阶段向中心移动，以便它们可以从数组的两侧开始，并逐渐向中心靠近。在算法开始时，我们希望<code>i</code>从左边开始，<code>j</code>从右边开始，因此我们将<code>i</code>和<code>j</code>设置为<code>l-1</code>和<code>r+1</code>，这样在第一次执行<code>do-while</code>循环时，<code>i</code>会加1，<code>j</code>会减1，所以<code>i</code>和<code>j</code>就分别指向了数组的第一个元素和最后一个元素。</p><p>​        关于<code>if (i &lt; j) swap(q[i], q[j]);</code>的判断，这一句是在对数组进行划分。这是快速排序算法的关键步骤，它选择一个元素作为“pivot”（在这个例子中，选择的是<code>q[l + r &gt;&gt; 1]</code>，也就是数组中间的元素），然后将所有小于pivot的元素放在pivot的左边，将所有大于pivot的元素放在pivot的右边。<code>if (i &lt; j) swap(q[i], q[j]);</code>就是这个划分过程的一部分，当<code>i</code>小于<code>j</code>时，说明当前的<code>i</code>位置的元素大于pivot，<code>j</code>位置的元素小于pivot，那么我们就交换这两个元素的位置。</p><p>​        我们来举一个生活中的例子。想象一下，你是一个老师，你有一堆学生的考试成绩，你想按照成绩将学生分成两组，一组是成绩高于平均值的，一组是成绩低于平均值的。这就好比是你选择了平均分作为你的“pivot”，然后你从最低分（<code>i=l-1</code>）和最高分（<code>j=r+1</code>）开始，分别向高分和低分方向寻找，直到找到一个低于平均分的高分学生和一个高于平均分的低分学生，然后你就让他们换位置，这就是<code>swap(q[i], q[j])</code>的过程。你一直重复这个过程，直到你检查完所有的学生，这样你就成功地将学生分成了两组。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学导论</title>
      <link href="//8058807d.html"/>
      <url>//8058807d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><p><strong>大纲：</strong></p><pre class="mermaid">graph TB    Computer("计算机")    Models("计算机模型")    TuringModel("图灵模型")    VonNeumannModel("冯-诺依曼模型")    ComputerParts("计算机三大部分")    Hardware("硬件")    Data("数据")    Software("软件")    Computer --> Models    Models --> TuringModel    Models --> VonNeumannModel    Computer --> ComputerParts    ComputerParts --> Hardware    ComputerParts --> Data    ComputerParts --> Software</pre><h3 id="1-1-图灵模型"><a href="#1-1-图灵模型" class="headerlink" title="1.1 图灵模型"></a>1.1 图灵模型</h3><h4 id="1-1-1-图灵机：什么是图灵机"><a href="#1-1-1-图灵机：什么是图灵机" class="headerlink" title="1.1.1 图灵机：什么是图灵机"></a>1.1.1 图灵机：什么是图灵机</h4><ul><li>Alan Turing（阿兰-图灵）1937年首次提出通用计算机设想：所有的计算都可能在一种特殊的机器上执行。</li><li>是一种数学上的描述，不是一台真实的机器。</li></ul><h4 id="1-1-2-数据处理器"><a href="#1-1-2-数据处理器" class="headerlink" title="1.1.2 数据处理器"></a>1.1.2 数据处理器</h4><p>首先暂且把计算机可以被看作一种接收数据输入、处理数据并产生数据输出的<strong>黑盒</strong>。</p><p><img src="https://p.ipic.vip/hcuo8v.png" alt="图片 1"></p><p>问题：没有确定计算机能处理的数据是什么。</p><h4 id="1-1-3-可编程数据处理器"><a href="#1-1-3-可编程数据处理器" class="headerlink" title="1.1.3 可编程数据处理器"></a>1.1.3 可编程数据处理器</h4><p>图灵模型：可编程计算机</p><p>​    <img src="https://p.ipic.vip/xa48wn.png" alt="image-20230728175245641" style="zoom: 67%;" />  </p><p>程序：告诉计算机对数据处理的的指令集合</p><p>输出数据：根据输入数据+程序，得到输出数据。</p><ul><li><p>相同程序，不同输入数据：输出数据不同。</p></li><li><p>相同输入数据，不同程序：输出数据不同。</p></li><li><p>相同输入数据，相同程序：输出数据相同。</p></li></ul><p>  <img src="https://p.ipic.vip/g53bvp.png" alt="image-20230728214730185" style="zoom: 50%;" /><img src="https://p.ipic.vip/4dspj7.png" alt="image-20230728214745517" style="zoom: 50%;" /></p><p><strong>通用图灵机：</strong>通用图灵机是对现代计算机的首次描述，该机器只要提供合适的程序就能做任何运算。</p><h3 id="1-2-冯-诺依曼模型"><a href="#1-2-冯-诺依曼模型" class="headerlink" title="1.2 冯-诺依曼模型"></a>1.2 冯-诺依曼模型</h3><h4 id="1-2-1-什么是冯-诺依曼模型"><a href="#1-2-1-什么是冯-诺依曼模型" class="headerlink" title="1.2.1 什么是冯-诺依曼模型"></a>1.2.1 什么是冯-诺依曼模型</h4><ul><li><p>科学家冯-诺依曼提出的模型理论。</p></li><li><p>基于通用图灵机建造的计算机都是在存储器(内存/寄存器)上存储数据。</p></li><li><p>鉴于程序和数据在逻辑上是相同的，因此程序也能存储在计算机的存储器中。</p></li></ul><h4 id="1-2-2-4个子系统"><a href="#1-2-2-4个子系统" class="headerlink" title="1.2.2 4个子系统"></a>1.2.2 4个子系统</h4><p><img src="https://p.ipic.vip/rjhyfc.png" alt="image-20230729095508630"></p><pre class="mermaid">graph LR  ControlUnit[控制单元]  ALU[算术逻辑单元]  Memory[存储器]  InputOutput[输入/输出单元]  ControlUnit --> ALU  ControlUnit --> Memory  ControlUnit --> InputOutput  InputOutput --> Memory  Memory --> ALU  ALU --> Memory</pre><ul><li><p><strong>存储器</strong>:用来存储数据和程序的区域。</p></li><li><p><strong>算术逻辑单元（ALU）</strong>：用来计算和逻辑运算的地方。</p></li><li><p><strong>控制单元</strong>：对存储器、算术逻辑单元、输入/输出等子系统进行控制操作。</p></li><li><p><strong>输入/输出单元</strong>：输入子系统负责从计算机外部接收输入数据，输出子系统负责从计算机处理结果输出到计算机外部。</p></li></ul><h4 id="1-2-3-存储程序概念"><a href="#1-2-3-存储程序概念" class="headerlink" title="1.2.3 存储程序概念"></a>1.2.3 存储程序概念</h4><pre class="mermaid">graph TB    Storage("存储器")    PrimaryStorage("主存储器(RAM)")    SecondaryStorage("次级存储器")    Cache("缓存")    HardDisk("硬盘驱动器")    SSD("固态硬盘 (SSD)")    CPU_Cache("CPU缓存")    Storage --> PrimaryStorage    Storage --> SecondaryStorage    Storage --> Cache    SecondaryStorage --> HardDisk    SecondaryStorage --> SSD    Cache --> CPU_Cache</pre><ul><li><p>冯-诺依曼模型要求程序也必须存储在存储器（内存）中。</p></li><li><p>现代计算机的存储单元用来存储程序和数据，这意味着程序和数据应该有相同的格式，实际上它们都是以位模式（0和1序列）存储在内存中。</p></li><li><p>什么是位模式？位模式是一种表示，用一串二进制数（0和1）来代表数据或者指令。</p></li></ul><h4 id="1-2-4-指令的顺序执行"><a href="#1-2-4-指令的顺序执行" class="headerlink" title="1.2.4 指令的顺序执行"></a>1.2.4 指令的顺序执行</h4><ul><li><p>冯-诺依曼模型中的一段程序是由一组数量有限的指令组成。</p></li><li><p>控制单元从内存中提取一条指令，解释指令，接着执行指令，也就是说指令是一条接着一条顺序执行的。</p></li></ul><h3 id="1-3-计算机组成部分"><a href="#1-3-计算机组成部分" class="headerlink" title="1.3 计算机组成部分"></a>1.3 计算机组成部分</h3><pre class="mermaid">graph TB    Computer("计算机")    Hardware("计算机硬件")    Data("计算机数据")    Software("计算机软件")    Computer --> Hardware    Computer --> Data    Computer --> Software</pre><p><strong>注：</strong>计算机硬件将在稍后章节提到。</p><h4 id="1-3-1-计算机组成部分-数据"><a href="#1-3-1-计算机组成部分-数据" class="headerlink" title="1.3.1 计算机组成部分-数据"></a>1.3.1 计算机组成部分-数据</h4><p>冯-诺依曼模型将计算机定义为一台数据处理机，它接收输入数据，处理数据，最后输出数据</p><ul><li>存储数据：计算机是一台<strong>电子设备</strong>，最好的数据存储方式应该是<strong>电子信号</strong>，以电子信号的<strong>出现和消失</strong>（位模式）来存储数据，即以两种状态之一来存储数据。但是日常生活中的数据（文本、图像、声音、视频等）不是以位模式存储的，不能直接存储到计算机中，除非将这类数据转换为位模式。</li></ul><p>为什么使用位模式？因为电子设备对位模式的实现简单（通电或不通电，高电压和低电压…）</p><ul><li>组织数据：在数据存储到计算机之前，需要合理有序的组织成不同的格式。将数据从计算机中输出也需要表现不同的形式。</li></ul><h4 id="1-3-2-计算机组成部分-软件"><a href="#1-3-2-计算机组成部分-软件" class="headerlink" title="1.3.2 计算机组成部分-软件"></a>1.3.2 计算机组成部分-软件</h4><ol><li><strong>算法</strong></li></ol><p>程序按一系列的指令执行使得编程成为可能，程序员通过指令集中的指令组合完成特定的运算任务，按照有序指令解决问题的的方法就是算法。</p><ol><li><strong>语言</strong></li></ol><ul><li><p>机器语言：程序员编写位模式（0和1的组合）的指令来完成任务。</p></li><li><p>符号语言：随着任务的复杂性越来越高，科学家研究使用符号来表示位模式指令，这样计算机编程语言就诞生了。</p></li></ul><ol><li><strong>软件工程</strong></li></ol><p>软件工程指结构化程序的设计和编写，为高效的程序开发而诞生的一门理论体系，这部分后面会讲到。</p><ol><li><strong>操作系统</strong></li></ol><p>这部分内容在后面会讲到。</p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
