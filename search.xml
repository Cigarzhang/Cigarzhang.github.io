<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言：指针和数组</title>
      <link href="//a33c1bed.html"/>
      <url>//a33c1bed.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-指针"><a href="#1-指针" class="headerlink" title="1. 指针"></a>1. 指针</h2><h3 id="1-1-指针和内存"><a href="#1-1-指针和内存" class="headerlink" title="1.1 指针和内存"></a>1.1 指针和内存</h3><h4 id="1-1-1简介"><a href="#1-1-1简介" class="headerlink" title="1.1.1简介"></a>1.1.1简介</h4><p>程序在编译后，会以三种形式使用内存：</p><ul><li>静态/ 全局内存 </li></ul><p>​        静态声明的变量分配在这里，全局变量也使用这部分内存。这些变量在程序开始运行时分配，直到程序终止才消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。</p><ul><li><p>自动内存</p><p>这些变量在函数内部声明，并且在函数被调用时才创建。 它们的作用域局限于函数内部，而且生命周期限制在函数的执行时间内。</p></li><li><p>动态内存</p><p>内存分配在堆上，可以根据需要释放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针，这是第2章重点。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">作用域</th><th style="text-align:left">生命周期</th></tr></thead><tbody><tr><td style="text-align:left">全局内存</td><td style="text-align:left">整个文件</td><td style="text-align:left">应用程序的生命周期</td></tr><tr><td style="text-align:left">静态内存</td><td style="text-align:left">声明它的函数内部</td><td style="text-align:left">应用程序的生命周期</td></tr><tr><td style="text-align:left">自动内存（局部内存）</td><td style="text-align:left">声明它的函数内部</td><td style="text-align:left">限制在函数执行时间内</td></tr><tr><td style="text-align:left">动态内存</td><td style="text-align:left">由引用该内存的指针决定</td><td style="text-align:left">直到内存释放</td></tr></tbody></table></div><p>​    指针变量包含内存中别的变量、对象或函数的地址。对象就是内存分配函数 (比如 malloc)分配的内存。指针通常根据所指的数据类型来声明。对象可以是任何C数据类型，如整数、字符、字符串或结构体。然而，指针本身并没有包含所引用数据的类型信息，指针只包含地址。</p><hr><h4 id="1-1-2初始化"><a href="#1-1-2初始化" class="headerlink" title="1.1.2初始化"></a>1.1.2初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明指针</span></span><br><span class="line"><span class="type">int</span> *pi1;</span><br><span class="line"><span class="type">int</span>* pi2;</span><br><span class="line"><span class="type">int</span>* pi3;</span><br><span class="line"><span class="type">int</span>*pi4;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci    <span class="comment">/*pci是一个指向整数常量的指针变量*/</span></span><br><span class="line"><span class="type">int</span> *pi;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">pi = &amp;num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Address of num: %d Value: %d\n&quot;</span>,&amp;num,num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Address of pi: %d Value: %d\n&quot;</span>,&amp;pi,pi);  <span class="comment">/*打印地址*/</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>格式说明符</th><th>含义</th></tr></thead><tbody><tr><td>%x</td><td>将值显示为十六进制数</td></tr><tr><td>%o</td><td>将值显示为八进制数</td></tr><tr><td>%p</td><td>将值显示为实现专用的格式，通常是十六进制数</td></tr></tbody></table></div><p><strong>Tips：</strong></p><ul><li>星号两边的空白字符无关紧要，空白符的使用是个人爱好；</li><li>星号将变量声明为指针；</li><li>pi 的内容最终应该赋值为一个整数变量的地址；</li><li>如果变量没有被初始化，将包含的是垃圾数据；</li><li>指针的实现中没有内部信息表明自己指向的是什么类型的数据或者内容是否合法，不过，指针有类型，而且如果没有正确使用，编译器会频繁抱怨；</li><li>尽管不经过初始化就可以使用指针，但只有初始化后，指针才会正常工作；</li><li>很多程序员都发现倒过来读声明就没那么复杂了；</li><li>地址操作符&amp;会返回操作数的地址，我们可以用这个操作符来初始化pi指针；</li><li>把整数赋值给指针 一般都会导致警告或错误，不过，也可以把整数转换为指向整数的指针<code>pi = (int *)num;</code></li><li>尽快初始化指针是一个好习惯;</li><li>%p和%x的不同之处在于:%p一般会把数字显示为十六进制大写。如果没有特别说明，我们用%p作为地址的说明符;</li><li>让打印地址变得更为复杂的是，在虛拟操作系统上显示的指针地址 一般不是真实的物理内存地址;</li><li>间接引用操作符 (*)返回指针变量指向的值，一般称为解引指针;</li><li>指针可以声明为指向函数,如<code>void (*foo) ();</code>,指针的名字是foo;</li></ul><hr><h4 id="1-1-3Null的概念"><a href="#1-1-3Null的概念" class="headerlink" title="1.1.3Null的概念"></a>1.1.3Null的概念</h4><p>​        NULL被赋值给指针就意味着指针不指向任何东西。null概念是指指针包含了一个特殊的值 ， 和别的指针不一样 ， 它没有指向任何 内存区域 。 两个null指针总是相等的。尽管不常见，但每一种指针类型 (如宇符指针和整数指针)都可以有对应的null指针类型。<br>​        Null概念是通过null指针常量来支持的一种抽象。这个常量可能是也可能不是常量0 ，C 程序员不需要关心实际的内部表示。<br>​        NULL宏是强制类型转换为void指针的整数常量0。在很多库中定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure><p>​        如果要把null值赋给pi，就像下面那样用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi = null;</span><br></pre></td></tr></table></figure><p>​        null指针和未初始化的指针不同。未初始化的指针可能包含任何值，而包含NULL的指针则不会引用内存中的任何地址。</p><p>​        有趣的是，我们可以给指针赋0，但是不能赋任何别的整数值。看一下下面的赋值操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pi = <span class="number">0</span>;</span><br><span class="line">pi = <span class="literal">NULL</span>;</span><br><span class="line">pi = <span class="number">100</span>; <span class="comment">//语法错误</span></span><br><span class="line">pi = num; <span class="comment">//语法错误</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>任何时候都不应该对null指针进行解引，因为它并不包含合法地址。执行这样的代码会导致程序终止；</li><li>指针被声明为全局或静态，就会在程序启动时被初始化为NULL。</li></ul><hr><h4 id="1-1-4void指针"><a href="#1-1-4void指针" class="headerlink" title="1.1.4void指针"></a>1.1.4void指针</h4><p>​        void指针是通用指针，用来存放任何数据类型的引用。下面的例子就是一个void 指针:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *pv;</span><br></pre></td></tr></table></figure><p>它有两个有趣的性质:</p><ul><li><p>void指针具有与char指针相同的形式和内存对齐方式;</p></li><li><p>void指针和别的指针永远不会相等，不过，两个赋值为NULL的void指针是相等的。</p></li></ul><p>​        任何指针都可以被赋给void指针，它可以被转换回原来的指针类型，这样的话指针的值和原指针的值是相等的。在下面的代码中，int指针被赋给void指针然后 ， 又被赋给int 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> *pi = &amp;num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Value of pi: %p\n&quot;</span>, pi); <span class="type">void</span>* pv = pi;</span><br><span class="line">pi = (<span class="type">int</span>*) pv;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Value of pi: %p\n&quot;</span>, pi);</span><br></pre></td></tr></table></figure><p>​        运行这段代码后，指针地址是 一样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value of pi: 100</span><br><span class="line">Value of pi: 100</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>void指针只用做数据指针，而不能用做函数指针；</li><li>用void指针的时候要小心，如果把任意指针转换为void指针，那就没有什么能阻止你再把它转换成不同的指针类型了；</li><li>sizeof操作符可以用在void指针上，不过我们无法把这个操作符用在void上。</li></ul><hr><h3 id="1-2-指针的长度和类型"><a href="#1-2-指针的长度和类型" class="headerlink" title="1.2 指针的长度和类型"></a>1.2 指针的长度和类型</h3><h4 id="1-2-1-机器内存模型"><a href="#1-2-1-机器内存模型" class="headerlink" title="1.2.1 机器内存模型"></a>1.2.1 机器内存模型</h4><div class="table-container"><table><thead><tr><th>数据类型</th><th>LP64</th><th>ILP64</th><th>LLP64</th><th>ILP32</th><th>LP32</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>short</td><td>16</td><td>16</td><td>16</td><td>16</td><td>16</td></tr><tr><td>_int32</td><td></td><td>32</td><td></td><td></td><td></td></tr><tr><td>int</td><td>32</td><td>64</td><td>32</td><td>32</td><td>16</td></tr><tr><td>long</td><td>64</td><td>64</td><td>32</td><td>32</td><td>32</td></tr><tr><td>long long</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>pointer</td><td>64</td><td>64</td><td>64</td><td>64</td><td>32</td></tr></tbody></table></div><hr><h4 id="1-2-2-指针相关的预定义类型"><a href="#1-2-2-指针相关的预定义类型" class="headerlink" title="1.2.2 指针相关的预定义类型"></a>1.2.2 指针相关的预定义类型</h4><p>​        使用指针时经常用到以下四种预定义类型 。 </p><ul><li><p>size_t</p><p>​        用于安全的表示长度</p></li><li><p>ptrdiff_t</p></li></ul><p>​                用于处理指针算数运算符</p><ul><li>intptr_t和uintptr_t    </li></ul><p>​                用于存储指针地址</p><p><strong><em>1. 理解size_t</em></strong></p><p><strong>定义：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZE_T</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">size_t</span> sizet= <span class="number">-5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> ‚sizet); <span class="comment">//把sizet当作有符号  打印-5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>,sizet); <span class="comment">//把sizet当作无符号整数 高位的1被当做2的乘幂 打印一个很大的数</span></span><br><span class="line"><span class="comment">/*正数则会正常显示*/</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li><p>size_t 用做sizeof操作符的返回值类型，同时也是很多函数的参数类型，包括malloc和strlen；</p></li><li><p>在声明诸如字符数或者数组索引这样的长度变量时用size_t 是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上；</p></li><li><p>通常size_t可以用来存放指针，但是假定size_t和指针一样长不是个好主意。</p></li><li><p>打印size_t 类型的值时要小心，这是无符号值，如果选错格式说明符，可能会得到不可靠的结果。推荐的格式说明符是%zu，不过</p><p>某些情况下不能用这个说明符，作为替代，可以考虑%u 或%lu。</p></li></ul><p><strong><em>2. 对指针使用sizeof操作符</em></strong></p><p>​    当需要用指针长度时，一定要用sizeof操作符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size of *char: %d\n&quot;</span>, <span class="keyword">sizeof</span> (<span class="type">char</span>*));</span><br></pre></td></tr></table></figure><blockquote><p>输出：<code>Size of *char: 4</code></p></blockquote><p><strong><em>3. 使用intptr _t和uintptr_t</em></strong></p><p><strong>定义：</strong></p><p>​        intptr_ t和uintptr_t类型用来存放指针地址。 它们提供了一种可移植且安全的方法声明指针，而且和系统中使用的指针长度相同，对于把指针转化成整数形式来说很有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">intptr_t</span> *pi = &amp;num;</span><br></pre></td></tr></table></figure><p>​        如果像下面那样试图把整数地址赋给uintptr_t 类型的指针，我们会得到一个语法错误:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> *pu = &amp;num;</span><br></pre></td></tr></table></figure><p>​        错误看起来是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: invalid conversion from &#x27;int*&#x27; to</span><br><span class="line">&#x27;uintptr_t* (aka unsigned int* &#x27; (-fpermissive)</span><br></pre></td></tr></table></figure><p>​        不过，用强制类型转换来赋值是可以的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intptr t *pi = &amp;num;</span><br><span class="line"><span class="type">uintptr_t</span> *pu = (<span class="type">uintptr_t</span>*)&amp;num;</span><br></pre></td></tr></table></figure><p>​        如果不转换类型，不能将uintptr_t 用于共他类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">uintptr_t</span> *pc = (<span class="type">uintptr_t</span>*)&amp;c;</span><br></pre></td></tr></table></figure><ul><li>避免把指针转换成整数。如果指针是64 位，整数只有4字节时就会丢失信息。</li><li>当可移植性和安全性变得重要时，就应该使用这些类型。</li></ul><h3 id="1-3-C的动态内存分配"><a href="#1-3-C的动态内存分配" class="headerlink" title="1.3 C的动态内存分配"></a>1.3 C的动态内存分配</h3><hr><hr><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h3 id="2-1-基本形式"><a href="#2-1-基本形式" class="headerlink" title="2.1 基本形式"></a>2.1 基本形式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> candy[<span class="number">365</span>];  <span class="comment">/*365个浮点数的数组*/</span></span><br><span class="line">  <span class="type">char</span> code[<span class="number">12</span>]  <span class="comment">/*12个字符的数组*/</span></span><br><span class="line">  <span class="type">int</span> states[<span class="number">50</span>];  <span class="comment">/*50个整数的数组*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> days[] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="keyword">sizeof</span> days / <span class="keyword">sizeof</span> days[<span class="number">0</span>]; index ++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Month %2d has %d days.\n&quot;</span>,index + <span class="number">1</span>,days[index]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>与普通变量相似，在初始化之前数组元素的数值是不定的；</li><li>初始化列表中的元素数目应和数组大小一致；</li><li>如果不初始化数组，数组和为初始化的普通变量一样，气筒存储的是无用值；</li><li>但是如果初始化部分数组，未初始化的数组则将被设置为0；</li><li>当使用空的方括号对数组进行初始化时，编译器会根据列表中的数值数目来确定数组大小；</li><li>注意for循环的控制语句。由于人工计算容易出错，因此可以让计算机来计算数组的打小。符sizeof给出其后的对象或类型的大小( 以字节为单位 )。因此sizeof days是整个数组的打戏哦啊（以字节为单位），sizeof days[0]是一个元素的大小（以字节为单位）。整个数组的大小厨艺单个元素的大小就是数组中元素的数目。</li><li>数组索引不能超过数组边界，不然会报错。</li></ul><h4 id="对数组使用const的方法"><a href="#对数组使用const的方法" class="headerlink" title="对数组使用const的方法"></a>对数组使用const的方法</h4><p>​        有时需要使用只读数组，也就是程序从数组中读取数值，但是程序不向数组中写数据。在这种情况下声明并初始化数组时，建议使用关键字const。声明数组<code>const int a[3] = &#123;1,2,3&#125;;</code></p><p>​        这样，程序会把数组中每个元素当成常量来处理。和普通变量一样，需要在声明const数组时对其进行初始化，因为在声明之后，不能再对它进行赋值。</p><h4 id="存储类定义"><a href="#存储类定义" class="headerlink" title="存储类定义"></a>存储类定义</h4><p>​        和其他变量相似，数组可以被定义为多种存储类(storage class)。也就是说，数组实在一个函数内声明，并且声明时没有使用关键字static。</p><p>​        不同存储类有时具有不同的属性。</p><h4 id="指定数组大小"><a href="#指定数组大小" class="headerlink" title="指定数组大小"></a>指定数组大小</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">8</span>;</span><br><span class="line"><span class="type">float</span> a1[<span class="number">5</span>];<span class="comment">//可以；</span></span><br><span class="line"><span class="type">float</span> a2[<span class="number">5</span>*<span class="number">2</span> + <span class="number">1</span>];  <span class="comment">//可以；</span></span><br><span class="line"><span class="type">float</span> a3[<span class="keyword">sizeof</span> (<span class="type">int</span>) + <span class="number">1</span>]; <span class="comment">//可以；</span></span><br><span class="line"><span class="type">float</span> a4[<span class="number">-4</span>];<span class="comment">//不可以，数组大小必须大于0；</span></span><br><span class="line"><span class="type">float</span> a5[<span class="number">0</span>];  <span class="comment">//不可以，数组大小必须大于0；</span></span><br><span class="line"><span class="type">float</span> a6[<span class="number">2.5</span>];<span class="comment">//不可以，数组大小必须是整数；</span></span><br><span class="line"><span class="type">float</span> a7[(<span class="type">int</span>) <span class="number">2.5</span>];   <span class="comment">//可以，把float类型指派为int类型；</span></span><br><span class="line"><span class="type">float</span> a8[n]; <span class="comment">//C99之前不允许；</span></span><br><span class="line"><span class="type">float</span> a9[m];  <span class="comment">// C99之前不允许。</span></span><br></pre></td></tr></table></figure><h2 id="2-3-C99新特性（指定初始化项目）"><a href="#2-3-C99新特性（指定初始化项目）" class="headerlink" title="2.3 C99新特性（指定初始化项目）"></a>2.3 C99新特性（指定初始化项目）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MONTHS 12</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> days[MONTHS] = &#123;<span class="number">31</span>,<span class="number">28</span>, [<span class="number">4</span>] = <span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,[<span class="number">1</span>] = <span class="number">29</span>&#125;;</span><br><span class="line">  <span class="type">int</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MONTHS; i ++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d %d\n&quot;</span>,i + <span class="number">1</span>,days[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    输出如下：</p><blockquote><p>1  31</p><p>2  29</p><p>3  0</p><p>4  0</p><p>5  31</p><p>6  30</p><p>7  31</p><p>8  0</p><p>9  0</p><p>10  0</p><p>11  0</p><p>12  0</p></blockquote><ol><li>如果在一个指定初始化项目后跟有不止一个值，则这些值将用来对后续的数组元素初始化。</li><li>如果多次对一个元素进行初始化，则最后一次有效。</li></ol><h2 id="2-4-多维数组"><a href="#2-4-多维数组" class="headerlink" title="2.4 多维数组"></a>2.4 多维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a[<span class="number">5</span>][<span class="number">12</span>];</span><br></pre></td></tr></table></figure><ul><li>a数组能存储5行12列的浮点数。</li><li>初始化数组时可以省略内部的花括号，只保留最外面的一对花括号。只要保证数值的个数是正确的。初始化效果就是一样的。</li></ul><p><strong>注：</strong>对于多维数组，可以这样直观的理解：一位数组是排成一行的数据，二维数组是放在一个平面上的数据，三维数组是把平面数据一层一层地垒起来。</p><h2 id="5-指针和数组"><a href="#5-指针和数组" class="headerlink" title="5. 指针和数组"></a>5. 指针和数组</h2><p><img src="https://p.ipic.vip/ml99nh.jpg" alt="CamScanner 07-20-2023 09.31" style="zoom: 25%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数组名同时也是该数组首元素的地址，两者都是常量，应为在程序运行的过程中它们保持不变*/</span></span><br><span class="line">flizny == &amp;flizny[<span class="number">0</span>] <span class="comment">//数组名是该数组首元素的地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">short</span> dates [size];</span><br><span class="line">  <span class="type">short</span> * pti;</span><br><span class="line">  <span class="type">short</span> index;</span><br><span class="line">  <span class="type">double</span> bills[SIZE];</span><br><span class="line">  <span class="type">double</span> * ptf;</span><br><span class="line">  </span><br><span class="line">  pti = dates; <span class="comment">//把数组地址赋给指针</span></span><br><span class="line">  ptf = bills;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%23s %10s\n&quot;</span>,<span class="string">&quot;short&quot;</span>,<span class="string">&quot;double&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; SIZE; index ++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pointers + %d: %10p %10p\n&quot;</span>,index,pti + index, ptf + index);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ul><li>在c中，对一个指针加1的结果是对该指针增加1个存储单元（storage unit）；</li><li>计算机需要知道存储对象所用的字节数，所以声明时不仅要有地址信息，还要声明它所指向对象的类型；</li><li>即使指针是指向标量的，也需要声明指针类型；否则*pt操作不能正确返回数值；</li><li>指针的数值就是它所指向的对象的地址；</li><li>在指针前运用运算符*就可以得到该指针所指向的对象的数值；</li><li>对指针加1，等价于对指针的值加上它指向的对象的字节大小。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dates + <span class="number">2</span> == &amp;date[<span class="number">2</span>]; <span class="comment">/*相同的地址  */</span></span><br><span class="line">* (dates + <span class="number">2</span>) == dates[<span class="number">2</span>];<span class="comment">/*相同的值*/</span></span><br><span class="line">* (dates + <span class="number">2</span>)  <span class="comment">/*dates的第3个元素的的值*/</span></span><br><span class="line">* dates + <span class="number">2</span>    <span class="comment">/*第一个元素的值和2相加*/</span></span><br></pre></td></tr></table></figure><p>​    这些关系总结了数组和指针间的密切关系：可以用指针标识数组的每个元素，并得到每个元素的数值。从本质上说，对同一个对象有两种不同的符号表示方法。C标准在描述数组时，确实借助了指针的概念。</p><hr><h2 id="6-函数、数组和指针"><a href="#6-函数、数组和指针" class="headerlink" title="6.函数、数组和指针"></a>6.函数、数组和指针</h2><h3 id="声明数组指针"><a href="#声明数组指针" class="headerlink" title="声明数组指针"></a>声明数组指针</h3><p>​        由于数组名就是数组首元素的地址，所以如果实际参是一个数组名，那么形式参量必须是与之相匹配的指针。在（而且仅在）这种场合中，C对于int ar[]和int *ar作出同样的解释，即ar是指向int的指针。由于原型允许省略名称，因此下面的4种原型都是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span> <span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> [],<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>​        定义函数时，名称是不可以省略的。因此，在定义时下面两种形式是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> ar[],<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用指针参数"><a href="#使用指针参数" class="headerlink" title="使用指针参数"></a>使用指针参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sump</span><span class="params">(<span class="type">int</span> *start, <span class="type">int</span> *end)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> marbles[SIZE] = &#123;<span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">31</span>, <span class="number">20</span>&#125;;</span><br><span class="line">  <span class="type">long</span> answer;</span><br><span class="line"></span><br><span class="line">  answer = sump(marbles, marbles + SIZE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The total number of marbles is %ld\n&quot;</span>,answer);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*使用指针算术*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sump</span><span class="params">(<span class="type">int</span> *start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">  &#123;</span><br><span class="line">    total += *start;    <span class="comment">/*把值累加到total上*/</span></span><br><span class="line">    start ++;    <span class="comment">/*把指针向前推进到下一个元素*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以把循环体代码改为<code>total += *start++;</code> 一元运算符<em>和++具有相等的优先级，但它在结合时是从右向左进行的。这就意味着++应用于start，而不是应用与 </em>start。也就是说，是指针自增1，而不是指针所指向的数据自增1。后缀形式（即start++，而不是++start）表示先把指针指向的数据到total上，然后指针再自增1。如果程序使用 <em>++start，则顺序就变为指针先自增1，然后再使用其指向的值。然后如果程序使用（ </em>start）++，那么会使用start所指向的数据，然后再使该数据自增1，而不是使指针自增1。这样，指针所指向的地址不变，但其中的元素却变成了一个数据。尽管 <em> start++比较常用，单位里清晰起见，应该使用</em> （start++）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">2</span>] = &#123;<span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line"><span class="type">int</span> moredata[<span class="number">2</span>] = &#123;<span class="number">300</span>, <span class="number">400</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> *pl, *pl, *p3;</span><br><span class="line">  </span><br><span class="line">  p1 = p2 = data;</span><br><span class="line">  p3 = moredata;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  *pl = %d,  *p2 = %d,   *p3 = %d\n&quot;</span>,   *p1     ,  *p2.   ,     *p3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*p1++ = %d,  *++p2 = %d,  (*p3) ++ = %d\n&quot;</span>,</span><br><span class="line">          *p1++.     , *++p2.    ,  (*p3) ++);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><blockquote><p> <em>p1 = 100,      </em>p2 = 100,         *p3 = 300</p><p> <em>p1++ = 100,  </em>p2 = 200,      *(p3) ++ = 300</p><p> <em>p1 = 200,      </em>p2 = 200,       *p3 = 301</p></blockquote><p>​        注：在C中，两个表达式ar[i]和* (ar + i) 的意义是等价的。而且不管ar是一个数组名还是一个指针变量，这两个表达式都可以工作。然而只有当ar是一个指针变量时，才可以使用ar++这样的表达式。</p><h2 id="7-指针操作"><a href="#7-指针操作" class="headerlink" title="7. 指针操作"></a>7. 指针操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> urn[<span class="number">5</span>] = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;;</span><br><span class="line">  <span class="type">int</span> *ptr1, *ptr2, *ptr3;</span><br><span class="line">  </span><br><span class="line">  ptr1 = urn;<span class="comment">//把一个地址赋给指针</span></span><br><span class="line">  ptr2 = &amp;urn[<span class="number">2</span>];<span class="comment">//同上</span></span><br><span class="line">  <span class="comment">//取得指针指向的值</span></span><br><span class="line">  <span class="comment">//并且得到指针的地址</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pointer value,&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学导论</title>
      <link href="//8058807d.html"/>
      <url>//8058807d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><h3 id="1-1-图灵模型"><a href="#1-1-图灵模型" class="headerlink" title="1.1 图灵模型"></a>1.1 图灵模型</h3><h4 id="1-1-1-图灵机：什么是图灵机"><a href="#1-1-1-图灵机：什么是图灵机" class="headerlink" title="1.1.1 图灵机：什么是图灵机"></a>1.1.1 图灵机：什么是图灵机</h4><ul><li>Alan Turing（阿兰-图灵）1937年首次提出通用计算机设想：所有的计算都可能在一种特殊的机器上执行。</li><li>是一种数学上的描述，不是一台真实的机器。</li></ul><h4 id="1-1-2-数据处理器"><a href="#1-1-2-数据处理器" class="headerlink" title="1.1.2 数据处理器"></a>1.1.2 数据处理器</h4><p>​        首先暂且把计算机可以被看作一种接收数据输入、处理数据并产生数据输出的<strong>黑盒</strong>。</p><p><img src="https://p.ipic.vip/hcuo8v.png" alt="图片 1"></p><p>​        问题：没有确定计算机能处理的数据是什么。</p><h4 id="1-1-3-可编程数据处理器"><a href="#1-1-3-可编程数据处理器" class="headerlink" title="1.1.3 可编程数据处理器"></a>1.1.3 可编程数据处理器</h4><p>​        图灵模型：可编程计算机</p><p>​        程序：告诉计算机对数据处理的的指令集合</p><p>​        输出数据：根据输入数据+程序，得到输出数据。</p><ul><li><p>相同程序，不同输入数据：输出数据不同。</p></li><li><p>相同输入数据，不同程序：输出数据不同。</p></li><li><p>相同输入数据，相同程序：输出数据相同。</p></li></ul><p>  <img src="https://p.ipic.vip/g53bvp.png" alt="image-20230728214730185" style="zoom: 50%;" /><img src="https://p.ipic.vip/4dspj7.png" alt="image-20230728214745517" style="zoom: 50%;" /></p><p>​        <strong>通用图灵机：</strong>通用图灵机是对现代计算机的首次描述，该机器只要提供合适的程序就能做任何运算。</p><h3 id="1-2-冯-诺依曼模型"><a href="#1-2-冯-诺依曼模型" class="headerlink" title="1.2 冯-诺依曼模型"></a>1.2 冯-诺依曼模型</h3><h4 id="1-2-1-什么是冯-诺依曼模型"><a href="#1-2-1-什么是冯-诺依曼模型" class="headerlink" title="1.2.1 什么是冯-诺依曼模型"></a>1.2.1 什么是冯-诺依曼模型</h4><ul><li><p>科学家冯-诺依曼提出的模型理论。</p></li><li><p>基于通用图灵机建造的计算机都是在存储器(内存/寄存器)上存储数据。</p></li><li><p>鉴于程序和数据在逻辑上是相同的，因此程序也能存储在计算机的存储器中。</p></li></ul><h4 id="1-2-2-4个子系统"><a href="#1-2-2-4个子系统" class="headerlink" title="1.2.2 4个子系统"></a>1.2.2 4个子系统</h4><p><img src="https://p.ipic.vip/rjhyfc.png" alt="image-20230729095508630" style="zoom: 50%;" /></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LR  ControlUnit[控制单元]  ALU[算术逻辑单元]  Memory[存储器]  InputOutput[输入&#x2F;输出单元]  ControlUnit --&gt; ALU  ControlUnit --&gt; Memory  ControlUnit --&gt; InputOutput  InputOutput --&gt; Memory  Memory --&gt; ALU  ALU --&gt; Memory  </pre></div><ul><li><p><strong>存储器</strong>:用来存储数据和程序的区域。</p></li><li><p><strong>算术逻辑单元（ALU）</strong>：用来计算和逻辑运算的地方。</p></li><li><p><strong>控制单元</strong>：对存储器、算术逻辑单元、输入/输出等子系统进行控制操作。</p></li><li><p><strong>输入/输出单元</strong>：输入子系统负责从计算机外部接收输入数据，输出子系统负责从计算机处理结果输出到计算机外部。</p></li></ul><h4 id="1-2-3-存储程序概念"><a href="#1-2-3-存储程序概念" class="headerlink" title="1.2.3 存储程序概念"></a>1.2.3 存储程序概念</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB    Storage(&quot;存储器&quot;)    PrimaryStorage(&quot;主存储器(RAM)&quot;)    SecondaryStorage(&quot;次级存储器&quot;)    Cache(&quot;缓存&quot;)    HardDisk(&quot;硬盘驱动器&quot;)    SSD(&quot;固态硬盘 (SSD)&quot;)    CPU_Cache(&quot;CPU缓存&quot;)    Storage --&gt; PrimaryStorage    Storage --&gt; SecondaryStorage    Storage --&gt; Cache    SecondaryStorage --&gt; HardDisk    SecondaryStorage --&gt; SSD    Cache --&gt; CPU_Cache  </pre></div><ul><li><p>冯-诺依曼模型要求程序也必须存储在存储器（内存）中。</p></li><li><p>现代计算机的存储单元用来存储程序和数据，这意味着程序和数据应该有相同的格式，实际上它们都是以位模式（0和1序列）存储在内存中。</p></li><li><p>什么是位模式？位模式是一种表示，用一串二进制数（0和1）来代表数据或者指令。</p></li></ul><h4 id="1-2-4-指令的顺序执行"><a href="#1-2-4-指令的顺序执行" class="headerlink" title="1.2.4 指令的顺序执行"></a>1.2.4 指令的顺序执行</h4><ul><li><p>冯-诺依曼模型中的一段程序是由一组数量有限的指令组成。</p></li><li><p>控制单元从内存中提取一条指令，解释指令，接着执行指令，也就是说指令是一条接着一条顺序执行的。</p></li></ul><h3 id="1-3-计算机组成部分"><a href="#1-3-计算机组成部分" class="headerlink" title="1.3 计算机组成部分"></a>1.3 计算机组成部分</h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TB    Computer(&quot;计算机&quot;)    Hardware(&quot;计算机硬件&quot;)    Data(&quot;计算机数据&quot;)    Software(&quot;计算机软件&quot;)    Computer --&gt; HardwareComputer --&gt; DataComputer --&gt; Software  </pre></div><p>​        <strong>注：</strong>计算机硬件将在稍后章节提到。</p><h4 id="1-3-1-计算机组成部分-数据"><a href="#1-3-1-计算机组成部分-数据" class="headerlink" title="1.3.1 计算机组成部分-数据"></a>1.3.1 计算机组成部分-数据</h4><p>​        冯-诺依曼模型将计算机定义为一台数据处理机，它接收输入数据，处理数据，最后输出数据</p><ul><li>存储数据：计算机是一台<strong>电子设备</strong>，最好的数据存储方式应该是<strong>电子信号</strong>，以电子信号的<strong>出现和消失</strong>（位模式）来存储数据，即以两种状态之一来存储数据。但是日常生活中的数据（文本、图像、声音、视频等）不是以位模式存储的，不能直接存储到计算机中，除非将这类数据转换为位模式。</li></ul><p>​        为什么使用位模式？因为电子设备对位模式的实现简单（通电或不通电，高电压和低电压…）</p><ul><li>组织数据：在数据存储到计算机之前，需要合理有序的组织成不同的格式。将数据从计算机中输出也需要表现不同的形式。</li></ul><h4 id="1-3-2-计算机组成部分-软件"><a href="#1-3-2-计算机组成部分-软件" class="headerlink" title="1.3.2 计算机组成部分-软件"></a>1.3.2 计算机组成部分-软件</h4><p><strong>1. 算法</strong></p><p>​        程序按一系列的指令执行使得编程成为可能，程序员通过指令集中的指令组合完成特定的运算任务，按照有序指令解决问题的的方法就是算法。</p><p><strong>2. 语言</strong></p><ul><li><p>机器语言：程序员编写位模式（0和1的组合）的指令来完成任务。</p></li><li><p>符号语言：随着任务的复杂性越来越高，科学家研究使用符号来表示位模式指令，这样计算机编程语言就诞生了。</p></li></ul><p><strong>3. 软件工程</strong></p><p>​        软件工程指结构化程序的设计和编写，为高效的程序开发而诞生的一门理论体系，这部分后面会讲到。</p><p><strong>4. 操作系统</strong></p><p>​        这部分内容在后面会讲到。</p><h2 id="2-数字系统"><a href="#2-数字系统" class="headerlink" title="2. 数字系统"></a>2. 数字系统</h2><h3 id="2-1-位置化数字系统"><a href="#2-1-位置化数字系统" class="headerlink" title="2.1 位置化数字系统"></a>2.1 位置化数字系统</h3><p>在位置化数字系统中，数字符号所占据的位置决定了其表示的值。</p><p>在该系统中，数字这样表示：</p><p><img src="https://p.ipic.vip/vu6e59.png" alt="image-20230730144809641" style="zoom: 33%;" /></p><p>它的值是：</p><p><img src="https://p.ipic.vip/nlk2td.png" alt="image-20230730145135621" style="zoom: 50%;" /></p><p>其中：S是一套符号集，b是底（或基数），b=S符号集中的符号总数，+/-表示数字为正或负。</p><h4 id="2-1-1-十进制系统-以10为底"><a href="#2-1-1-十进制系统-以10为底" class="headerlink" title="2.1.1 十进制系统(以10为底)"></a>2.1.1 十进制系统(以10为底)</h4><p>符号集$S={0,1,2,3,4,5,6,7,8,9}$</p><p>底$b=10$</p><p><img src="https://p.ipic.vip/zlhvgn.png" alt="image-20230730145316735" style="zoom:40%;" /></p><p>为了简便，通常省略括号、底、和正号。如$+(552.31)$写成$552.31$，底和加号是隐含的。</p><p><strong>注释：</strong></p><ol><li><p>这些符号不能直接存储在计算机中。</p></li><li><p>计算机存储正负数的方式不同。</p></li></ol><p><img src="https://p.ipic.vip/fcdvdd.png" alt="image-20230730145728629"></p><p><img src="https://p.ipic.vip/21re5f.png" alt="image-20230730145748883"></p><p><img src="https://p.ipic.vip/n9twyz.png" alt="image-20230730145915270"></p><p><img src="https://p.ipic.vip/ri6c40.png" alt="image-20230730145932443"></p><p><img src="https://p.ipic.vip/xjwgrs.png" alt="image-20230730145941641"></p><p><img src="https://p.ipic.vip/7hxt26.png" alt="image-20230730150004600" style="zoom: 50%;" /></p><h4 id="2-1-2-二进制系统-以2为底"><a href="#2-1-2-二进制系统-以2为底" class="headerlink" title="2.1.2 二进制系统(以2为底)"></a>2.1.2 二进制系统(以2为底)</h4><h4 id="2-1-3-十六进制系统-以16为底"><a href="#2-1-3-十六进制系统-以16为底" class="headerlink" title="2.1.3 十六进制系统(以16为底)"></a>2.1.3 十六进制系统(以16为底)</h4><h4 id="2-1-4-八进制系统-以8为底"><a href="#2-1-4-八进制系统-以8为底" class="headerlink" title="2.1.4 八进制系统(以8为底)"></a>2.1.4 八进制系统(以8为底)</h4>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
